{"version":3,"sources":["node_modules/interactjs/interact.js"],"names":["require","register","exports","module","__makeRelativeRequire","realWindow","blank","isElement","o","_window","getWindow","window","test","Element","nodeType","nodeName","isWindow","thing","Window","isDocFrag","DocumentFragment","isArray","isObject","undefined","length","isFunction","splice","isNumber","isBool","isString","trySelector","value","document","querySelector","extend","dest","source","prop","pointerExtend","deprecated","vendor","prefixedPropREs","indexOf","copyCoords","src","page","x","y","client","timeStamp","setEventXY","targetObj","pointers","interaction","pointer","pointerAverage","getPageXY","tmpXY","getClientXY","Date","getTime","setEventDeltas","prev","cur","dt","Math","max","speed","hypot","vx","vy","isNativePointer","Event","supportsTouch","Touch","getXY","type","xy","isOperaMobile","scrollX","scrollY","getScrollXY","win","documentElement","scrollLeft","scrollTop","getPointerId","pointerId","identifier","getActualElement","element","SVGElementInstance","correspondingUseElement","node","rootNode","ownerDocument","defaultView","parentWindow","getElementClientRect","clientRect","SVGElement","getBoundingClientRect","getClientRects","left","right","top","bottom","width","height","getElementRect","isIOS7","scroll","getTouchPair","event","touches","changedTouches","average","pageX","pageY","clientX","clientY","screenX","screenY","i","touchBBox","minX","min","minY","maxX","maxY","touchDistance","deltaSource","defaultOptions","sourceX","sourceY","dx","dy","touchAngle","prevAngle","angle","atan","PI","dr","drClamped","getOriginXY","interactable","origin","options","parentElement","getRect","closest","_getQBezierValue","t","p1","p2","p3","iT","getQuadraticCurvePoint","startX","startY","cpX","cpY","endX","endY","position","easeOutQuad","b","c","d","nodeContains","parent","child","parentNode","selector","matchesSelector","host","inContext","_context","testIgnore","interactableElement","ignoreFrom","matchesUpTo","testAllow","allowFrom","checkAxis","axis","thisAxis","drag","checkSnap","action","snap","enabled","checkRestrict","restrict","checkAutoScroll","autoScroll","withinInteractionLimit","maxActions","name","maxPerElement","activeInteractions","targetCount","targetElementCount","len","interactions","otherAction","prepared","active","interacting","maxInteractions","target","indexOfDeepestElement","elements","dropzone","n","deepestZone","index","deepestZoneParents","dropzoneParents","unshift","HTMLElement","SVGSVGElement","ownerSVGElement","parents","lastChild","previousSibling","Interaction","this","dropTarget","dropElement","prevDropTarget","prevDropElement","edges","matches","matchElements","inertiaStatus","smoothEnd","ending","startEvent","upCoords","xe","ye","sx","sy","t0","vx0","vys","duration","resumeDx","resumeDy","lambda_v0","one_ve_v0","Function","prototype","bind","boundInertiaFrame","inertiaFrame","boundSmoothEndFrame","smoothEndFrame","that","activeDrops","dropzones","rects","pointerIds","downTargets","downTimes","holdTimers","prevCoords","curCoords","startCoords","pointerDelta","downEvent","downPointer","_eventTarget","_curEventTarget","prevEvent","tapTime","prevTap","startOffset","restrictOffset","snapOffsets","gesture","start","startDistance","prevDistance","distance","scale","startAngle","snapStatus","realX","realY","snappedX","snappedY","targets","locked","changed","restrictStatus","restrictedX","restrictedY","restricted","pointerIsDown","pointerWasMoved","gesturing","dragging","resizing","resizeAxes","mouse","push","getInteractionFromPointer","eventType","eventTarget","mouseEvent","pointerType","id","inertia","allowResume","supportsPointerEvent","contains","doOnInteractions","method","path","curEventTarget","currentTarget","prevTouchTime","_updateEventTargets","InteractEvent","phase","related","starting","coords","relativePoints","range","elementRect","x0","y0","clientX0","clientY0","ctrlKey","altKey","shiftKey","metaKey","button","buttons","detail","relatedTarget","zeroResumeDelta","resize","square","axes","box","ds","da","prevScale","velocityX","velocityY","atan2","overlap","up","down","swipe","velocity","preventOriginalDefault","originalEvent","preventDefault","getActionCursor","cursor","actionCursors","cursorKey","edgeNames","checkResizeEdge","rect","margin","defaultActionChecker","resizeEdges","shouldResize","actionIsEnabled","resizeOptions","edge","validateAction","actionName","delegateListener","useCapture","fakeEvent","delegated","delegatedEvents","selectors","context","contexts","listeners","j","delegateUseCapture","call","interact","interactables","get","Interactable","_element","_iEvents","Node","events","add","pEventTypes","pointerDown","move","pointerHover","_doc","documents","listenToDocument","set","warnOnce","message","warned","console","warn","apply","arguments","endAllInteractions","pointerEnd","doc","PointerEvent","MSPointerEvent","over","out","cancel","selectorDown","pointerMove","pointerOver","pointerOut","pointerUp","pointerCancel","autoScrollMove","frameElement","parentDoc","error","windowParentError","checkAndPreventDefault","useAttachEvent","currentAction","array","nodeList","ie8MatchesSelector","replace","prefixedMatchesSelector","limit","el","createTextNode","wrap","sqrt","dynamicDrop","base","accept","actionChecker","styleCursor","dropChecker","manualStart","Infinity","drop","preserveAspectRatio","NaN","invert","perAction","endOnly","offsets","container","resistance","minSpeed","endSpeed","smoothEndDuration","_holdDuration","now","dtx","prevTimeX","dty","prevTimeY","scrollBy","isScrolling","cancelFrame","reqFrame","stop","DocumentTouch","navigator","userAgent","pointerMoveTolerance","all","atob","resizex","resizey","resizexy","resizetop","resizeleft","resizebottom","resizeright","resizetopleft","resizebottomright","resizetopright","resizebottomleft","wheelEvent","eventTypes","globalEvents","appName","match","platform","appVersion","requestAnimationFrame","cancelAnimationFrame","listener","elementIndex","typeCount","attachedListeners","supplied","wrapped","useCount","ret","listenerIndex","immediatePropagationStopped","srcElement","preventDef","stopPropagation","stopProp","stopImmediatePropagation","stopImmProp","addEvent","on","Boolean","remove","removeEvent","hasOwnProperty","returnValue","cancelBubble","_elements","_targets","_attachedListeners","webkit","ptr","pushCurMatches","curMatches","curMatchElements","prevTargetElement","addPointer","elementInteractable","elementAction","getAction","forEachSelector","validateSelector","style","pushMatches","querySelectorAll","eventCopy","pointerIndex","setTimeout","pointerHold","collectEventTargets","forceAction","newAction","setModifications","preEnd","shouldMove","shouldSnap","shouldRestrict","setSnapping","setRestriction","setStartOffsets","snapOffset","offset","pageUp","clientUp","inertiaPosition","recordPointer","duplicateMove","clearTimeout","absX","abs","absY","targetAxis","thisInteraction","getDraggable","selectorInteractable","dragStart","dragEvent","fire","setActiveDrops","dropEvents","getDropEvents","activate","fireActiveDrops","dragMove","draggableElement","getDrop","leave","enter","resizeStart","resizeEvent","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","current","previous","delta","deltaRect","resizeMove","invertible","originalEdges","swap","gestureStart","gestureEvent","gestureMove","isNaN","removePointer","ie8Dblclick","endEvent","inertiaOptions","pointerSpeed","inertiaPossible","endSnap","endRestrict","snapRestrict","vy0","v0","calcInertia","statusObject","useStatusXY","modifiedXe","modifiedYe","deactivate","collectDrops","drops","dropElements","currentElement","prevElement","dragElement","possibleDrops","validDrops","dropCheck","dropIndex","pointerEvent","draggable","dragLeave","prevDropzone","dragEnter","dragmove","clearTargets","lambda","te","progress","exp","quadPoint","collectSelectors","els","isSet","firePointers","interval","createNewDoubleTap","originalPointer","propagationStopped","doubleTap","matchElement","pageCoords","status","relIndex","relative","inRange","snapChanged","restriction","prevent","inertiaDur","log","innerWidth","innerHeight","interactionListeners","indexOfElement","callback","setOnEvents","phases","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","onstart","onmove","onend","oninertiastart","setPerAction","option","checker","dropped","dropOverlap","horizontal","vertical","dragRect","cx","cy","overlapArea","overlapRatio","newValue","resizable","squareResize","gesturable","actions","setOptions","thisOption","mode","createSnapGrid","gridOffset","grid","anchors","paths","elementOrigin","allActions","rectChecker","iEvent","onEvent","funcName","search","trim","split","off","eventList","matchFound","fn","useCap","methods","perActions","settings","setting","unset","enableDragging","enableResizing","enableGesturing","debug","downTime","getPointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","newvalue","offsetX","offsetY","gridx","round","gridy","newX","newY","elems","lastTime","vendors","currTime","timeToCall","define","amd"],"mappings":"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","file":"docs/vendor.js.map","sourcesContent":["/**\n * interact.js v1.2.8\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n(function (realWindow) {\n    'use strict';\n\n    // return early if there's no window to work with (eg. Node.js)\n    if (!realWindow) { return; }\n\n    var // get wrapped window if using Shadow DOM polyfill\n        window = (function () {\n            // create a TextNode\n            var el = realWindow.document.createTextNode('');\n\n            // check if it's wrapped by a polyfill\n            if (el.ownerDocument !== realWindow.document\n                && typeof realWindow.wrap === 'function'\n                && realWindow.wrap(el) === el) {\n                // return wrapped window\n                return realWindow.wrap(realWindow);\n            }\n\n            // no Shadow DOM polyfil or native implementation\n            return realWindow;\n        }()),\n\n        document           = window.document,\n        DocumentFragment   = window.DocumentFragment   || blank,\n        SVGElement         = window.SVGElement         || blank,\n        SVGSVGElement      = window.SVGSVGElement      || blank,\n        SVGElementInstance = window.SVGElementInstance || blank,\n        HTMLElement        = window.HTMLElement        || window.Element,\n\n        PointerEvent = (window.PointerEvent || window.MSPointerEvent),\n        pEventTypes,\n\n        hypot = Math.hypot || function (x, y) { return Math.sqrt(x * x + y * y); },\n\n        tmpXY = {},     // reduce object creation in getXY()\n\n        documents       = [],   // all documents being listened to\n\n        interactables   = [],   // all set interactables\n        interactions    = [],   // all interactions\n\n        dynamicDrop     = false,\n\n        // {\n        //      type: {\n        //          selectors: ['selector', ...],\n        //          contexts : [document, ...],\n        //          listeners: [[listener, useCapture], ...]\n        //      }\n        //  }\n        delegatedEvents = {},\n\n        defaultOptions = {\n            base: {\n                accept        : null,\n                actionChecker : null,\n                styleCursor   : true,\n                preventDefault: 'auto',\n                origin        : { x: 0, y: 0 },\n                deltaSource   : 'page',\n                allowFrom     : null,\n                ignoreFrom    : null,\n                _context      : document,\n                dropChecker   : null\n            },\n\n            drag: {\n                enabled: false,\n                manualStart: true,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: null,\n                restrict: null,\n                inertia: null,\n                autoScroll: null,\n\n                axis: 'xy'\n            },\n\n            drop: {\n                enabled: false,\n                accept: null,\n                overlap: 'pointer'\n            },\n\n            resize: {\n                enabled: false,\n                manualStart: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: null,\n                restrict: null,\n                inertia: null,\n                autoScroll: null,\n\n                square: false,\n                preserveAspectRatio: false,\n                axis: 'xy',\n\n                // use default margin\n                margin: NaN,\n\n                // object with props left, right, top, bottom which are\n                // true/false values to resize when the pointer is over that edge,\n                // CSS selectors to match the handles for each direction\n                // or the Elements for each handle\n                edges: null,\n\n                // a value of 'none' will limit the resize rect to a minimum of 0x0\n                // 'negate' will alow the rect to have negative width/height\n                // 'reposition' will keep the width/height positive by swapping\n                // the top and bottom edges and/or swapping the left and right edges\n                invert: 'none'\n            },\n\n            gesture: {\n                manualStart: false,\n                enabled: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                restrict: null\n            },\n\n            perAction: {\n                manualStart: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: {\n                    enabled     : false,\n                    endOnly     : false,\n                    range       : Infinity,\n                    targets     : null,\n                    offsets     : null,\n\n                    relativePoints: null\n                },\n\n                restrict: {\n                    enabled: false,\n                    endOnly: false\n                },\n\n                autoScroll: {\n                    enabled     : false,\n                    container   : null,     // the item that is scrolled (Window or HTMLElement)\n                    margin      : 60,\n                    speed       : 300       // the scroll speed in pixels per second\n                },\n\n                inertia: {\n                    enabled          : false,\n                    resistance       : 10,    // the lambda in exponential decay\n                    minSpeed         : 100,   // target speed must be above this for inertia to start\n                    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n                    allowResume      : true,  // allow resuming an action in inertia phase\n                    zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n                    smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia\n                }\n            },\n\n            _holdDuration: 600\n        },\n\n        // Things related to autoScroll\n        autoScroll = {\n            interaction: null,\n            i: null,    // the handle returned by window.setInterval\n            x: 0, y: 0, // Direction each pulse is to scroll in\n\n            // scroll the window by the values in scroll.x/y\n            scroll: function () {\n                var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n                    container = options.container || getWindow(autoScroll.interaction.element),\n                    now = new Date().getTime(),\n                    // change in time in seconds\n                    dtx = (now - autoScroll.prevTimeX) / 1000,\n                    dty = (now - autoScroll.prevTimeY) / 1000,\n                    vx, vy, sx, sy;\n\n                // displacement\n                if (options.velocity) {\n                  vx = options.velocity.x;\n                  vy = options.velocity.y;\n                }\n                else {\n                  vx = vy = options.speed\n                }\n \n                sx = vx * dtx;\n                sy = vy * dty;\n\n                if (sx >= 1 || sy >= 1) {\n                    if (isWindow(container)) {\n                        container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n                    }\n                    else if (container) {\n                        container.scrollLeft += autoScroll.x * sx;\n                        container.scrollTop  += autoScroll.y * sy;\n                    }\n\n                    if (sx >=1) autoScroll.prevTimeX = now;\n                    if (sy >= 1) autoScroll.prevTimeY = now;\n                }\n\n                if (autoScroll.isScrolling) {\n                    cancelFrame(autoScroll.i);\n                    autoScroll.i = reqFrame(autoScroll.scroll);\n                }\n            },\n\n            isScrolling: false,\n            prevTimeX: 0,\n            prevTimeY: 0,\n\n            start: function (interaction) {\n                autoScroll.isScrolling = true;\n                cancelFrame(autoScroll.i);\n\n                autoScroll.interaction = interaction;\n                autoScroll.prevTimeX = new Date().getTime();\n                autoScroll.prevTimeY = new Date().getTime();\n                autoScroll.i = reqFrame(autoScroll.scroll);\n            },\n\n            stop: function () {\n                autoScroll.isScrolling = false;\n                cancelFrame(autoScroll.i);\n            }\n        },\n\n        // Does the browser support touch input?\n        supportsTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),\n\n        // Does the browser support PointerEvents\n        // Avoid PointerEvent bugs introduced in Chrome 55\n        supportsPointerEvent = PointerEvent && !/Chrome/.test(navigator.userAgent),\n\n        // Less Precision with touch input\n        margin = supportsTouch || supportsPointerEvent? 20: 10,\n\n        pointerMoveTolerance = 1,\n\n        // for ignoring browser's simulated mouse events\n        prevTouchTime = 0,\n\n        // Allow this many interactions to happen simultaneously\n        maxInteractions = Infinity,\n\n        // Check if is IE9 or older\n        actionCursors = (document.all && !window.atob) ? {\n            drag    : 'move',\n            resizex : 'e-resize',\n            resizey : 's-resize',\n            resizexy: 'se-resize',\n\n            resizetop        : 'n-resize',\n            resizeleft       : 'w-resize',\n            resizebottom     : 's-resize',\n            resizeright      : 'e-resize',\n            resizetopleft    : 'se-resize',\n            resizebottomright: 'se-resize',\n            resizetopright   : 'ne-resize',\n            resizebottomleft : 'ne-resize',\n\n            gesture : ''\n        } : {\n            drag    : 'move',\n            resizex : 'ew-resize',\n            resizey : 'ns-resize',\n            resizexy: 'nwse-resize',\n\n            resizetop        : 'ns-resize',\n            resizeleft       : 'ew-resize',\n            resizebottom     : 'ns-resize',\n            resizeright      : 'ew-resize',\n            resizetopleft    : 'nwse-resize',\n            resizebottomright: 'nwse-resize',\n            resizetopright   : 'nesw-resize',\n            resizebottomleft : 'nesw-resize',\n\n            gesture : ''\n        },\n\n        actionIsEnabled = {\n            drag   : true,\n            resize : true,\n            gesture: true\n        },\n\n        // because Webkit and Opera still use 'mousewheel' event type\n        wheelEvent = 'onmousewheel' in document? 'mousewheel': 'wheel',\n\n        eventTypes = [\n            'dragstart',\n            'dragmove',\n            'draginertiastart',\n            'dragend',\n            'dragenter',\n            'dragleave',\n            'dropactivate',\n            'dropdeactivate',\n            'dropmove',\n            'drop',\n            'resizestart',\n            'resizemove',\n            'resizeinertiastart',\n            'resizeend',\n            'gesturestart',\n            'gesturemove',\n            'gestureinertiastart',\n            'gestureend',\n\n            'down',\n            'move',\n            'up',\n            'cancel',\n            'tap',\n            'doubletap',\n            'hold'\n        ],\n\n        globalEvents = {},\n\n        // Opera Mobile must be handled differently\n        isOperaMobile = navigator.appName == 'Opera' &&\n            supportsTouch &&\n            navigator.userAgent.match('Presto'),\n\n        // scrolling doesn't change the result of getClientRects on iOS 7\n        isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform)\n                         && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n        // prefix matchesSelector\n        prefixedMatchesSelector = 'matches' in Element.prototype?\n                'matches': 'webkitMatchesSelector' in Element.prototype?\n                    'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n                        'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n                            'oMatchesSelector': 'msMatchesSelector',\n\n        // will be polyfill function if browser is IE8\n        ie8MatchesSelector,\n\n        // native requestAnimationFrame or polyfill\n        reqFrame = realWindow.requestAnimationFrame,\n        cancelFrame = realWindow.cancelAnimationFrame,\n\n        // Events wrapper\n        events = (function () {\n            var useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),\n                addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',\n                removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',\n                on             = useAttachEvent? 'on': '',\n\n                elements          = [],\n                targets           = [],\n                attachedListeners = [];\n\n            function add (element, type, listener, useCapture) {\n                var elementIndex = indexOf(elements, element),\n                    target = targets[elementIndex];\n\n                if (!target) {\n                    target = {\n                        events: {},\n                        typeCount: 0\n                    };\n\n                    elementIndex = elements.push(element) - 1;\n                    targets.push(target);\n\n                    attachedListeners.push((useAttachEvent ? {\n                            supplied: [],\n                            wrapped : [],\n                            useCount: []\n                        } : null));\n                }\n\n                if (!target.events[type]) {\n                    target.events[type] = [];\n                    target.typeCount++;\n                }\n\n                if (!contains(target.events[type], listener)) {\n                    var ret;\n\n                    if (useAttachEvent) {\n                        var listeners = attachedListeners[elementIndex],\n                            listenerIndex = indexOf(listeners.supplied, listener);\n\n                        var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n                            if (!event.immediatePropagationStopped) {\n                                event.target = event.srcElement;\n                                event.currentTarget = element;\n\n                                event.preventDefault = event.preventDefault || preventDef;\n                                event.stopPropagation = event.stopPropagation || stopProp;\n                                event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n                                if (/mouse|click/.test(event.type)) {\n                                    event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n                                    event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n                                }\n\n                                listener(event);\n                            }\n                        };\n\n                        ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\n                        if (listenerIndex === -1) {\n                            listeners.supplied.push(listener);\n                            listeners.wrapped.push(wrapped);\n                            listeners.useCount.push(1);\n                        }\n                        else {\n                            listeners.useCount[listenerIndex]++;\n                        }\n                    }\n                    else {\n                        ret = element[addEvent](type, listener, useCapture || false);\n                    }\n                    target.events[type].push(listener);\n\n                    return ret;\n                }\n            }\n\n            function remove (element, type, listener, useCapture) {\n                var i,\n                    elementIndex = indexOf(elements, element),\n                    target = targets[elementIndex],\n                    listeners,\n                    listenerIndex,\n                    wrapped = listener;\n\n                if (!target || !target.events) {\n                    return;\n                }\n\n                if (useAttachEvent) {\n                    listeners = attachedListeners[elementIndex];\n                    listenerIndex = indexOf(listeners.supplied, listener);\n                    wrapped = listeners.wrapped[listenerIndex];\n                }\n\n                if (type === 'all') {\n                    for (type in target.events) {\n                        if (target.events.hasOwnProperty(type)) {\n                            remove(element, type, 'all');\n                        }\n                    }\n                    return;\n                }\n\n                if (target.events[type]) {\n                    var len = target.events[type].length;\n\n                    if (listener === 'all') {\n                        for (i = 0; i < len; i++) {\n                            remove(element, type, target.events[type][i], Boolean(useCapture));\n                        }\n                        return;\n                    } else {\n                        for (i = 0; i < len; i++) {\n                            if (target.events[type][i] === listener) {\n                                element[removeEvent](on + type, wrapped, useCapture || false);\n                                target.events[type].splice(i, 1);\n\n                                if (useAttachEvent && listeners) {\n                                    listeners.useCount[listenerIndex]--;\n                                    if (listeners.useCount[listenerIndex] === 0) {\n                                        listeners.supplied.splice(listenerIndex, 1);\n                                        listeners.wrapped.splice(listenerIndex, 1);\n                                        listeners.useCount.splice(listenerIndex, 1);\n                                    }\n                                }\n\n                                break;\n                            }\n                        }\n                    }\n\n                    if (target.events[type] && target.events[type].length === 0) {\n                        target.events[type] = null;\n                        target.typeCount--;\n                    }\n                }\n\n                if (!target.typeCount) {\n                    targets.splice(elementIndex, 1);\n                    elements.splice(elementIndex, 1);\n                    attachedListeners.splice(elementIndex, 1);\n                }\n            }\n\n            function preventDef () {\n                this.returnValue = false;\n            }\n\n            function stopProp () {\n                this.cancelBubble = true;\n            }\n\n            function stopImmProp () {\n                this.cancelBubble = true;\n                this.immediatePropagationStopped = true;\n            }\n\n            return {\n                add: add,\n                remove: remove,\n                useAttachEvent: useAttachEvent,\n\n                _elements: elements,\n                _targets: targets,\n                _attachedListeners: attachedListeners\n            };\n        }());\n\n    function blank () {}\n\n    function isElement (o) {\n        if (!o || (typeof o !== 'object')) { return false; }\n\n        var _window = getWindow(o) || window;\n\n        return (/object|function/.test(typeof _window.Element)\n            ? o instanceof _window.Element //DOM2\n            : o.nodeType === 1 && typeof o.nodeName === \"string\");\n    }\n    function isWindow (thing) { return thing === window || !!(thing && thing.Window) && (thing instanceof thing.Window); }\n    function isDocFrag (thing) { return !!thing && thing instanceof DocumentFragment; }\n    function isArray (thing) {\n        return isObject(thing)\n                && (typeof thing.length !== undefined)\n                && isFunction(thing.splice);\n    }\n    function isObject   (thing) { return !!thing && (typeof thing === 'object'); }\n    function isFunction (thing) { return typeof thing === 'function'; }\n    function isNumber   (thing) { return typeof thing === 'number'  ; }\n    function isBool     (thing) { return typeof thing === 'boolean' ; }\n    function isString   (thing) { return typeof thing === 'string'  ; }\n\n    function trySelector (value) {\n        if (!isString(value)) { return false; }\n\n        // an exception will be raised if it is invalid\n        document.querySelector(value);\n        return true;\n    }\n\n    function extend (dest, source) {\n        for (var prop in source) {\n            dest[prop] = source[prop];\n        }\n        return dest;\n    }\n\n    var prefixedPropREs = {\n      webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n    };\n\n    function pointerExtend (dest, source) {\n        for (var prop in source) {\n          var deprecated = false;\n\n          // skip deprecated prefixed properties\n          for (var vendor in prefixedPropREs) {\n            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n              deprecated = true;\n              break;\n            }\n          }\n\n          if (!deprecated) {\n            dest[prop] = source[prop];\n          }\n        }\n        return dest;\n    }\n\n    function copyCoords (dest, src) {\n        dest.page = dest.page || {};\n        dest.page.x = src.page.x;\n        dest.page.y = src.page.y;\n\n        dest.client = dest.client || {};\n        dest.client.x = src.client.x;\n        dest.client.y = src.client.y;\n\n        dest.timeStamp = src.timeStamp;\n    }\n\n    function setEventXY (targetObj, pointers, interaction) {\n        var pointer = (pointers.length > 1\n                       ? pointerAverage(pointers)\n                       : pointers[0]);\n\n        getPageXY(pointer, tmpXY, interaction);\n        targetObj.page.x = tmpXY.x;\n        targetObj.page.y = tmpXY.y;\n\n        getClientXY(pointer, tmpXY, interaction);\n        targetObj.client.x = tmpXY.x;\n        targetObj.client.y = tmpXY.y;\n\n        targetObj.timeStamp = new Date().getTime();\n    }\n\n    function setEventDeltas (targetObj, prev, cur) {\n        targetObj.page.x     = cur.page.x      - prev.page.x;\n        targetObj.page.y     = cur.page.y      - prev.page.y;\n        targetObj.client.x   = cur.client.x    - prev.client.x;\n        targetObj.client.y   = cur.client.y    - prev.client.y;\n        targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\n        // set pointer velocity\n        var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n        targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n        targetObj.page.vx      = targetObj.page.x / dt;\n        targetObj.page.vy      = targetObj.page.y / dt;\n\n        targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n        targetObj.client.vx    = targetObj.client.x / dt;\n        targetObj.client.vy    = targetObj.client.y / dt;\n    }\n\n    function isNativePointer (pointer) {\n        return (pointer instanceof window.Event\n            || (supportsTouch && window.Touch && pointer instanceof window.Touch));\n    }\n\n    // Get specified X/Y coords for mouse or event.touches[0]\n    function getXY (type, pointer, xy) {\n        xy = xy || {};\n        type = type || 'page';\n\n        xy.x = pointer[type + 'X'];\n        xy.y = pointer[type + 'Y'];\n\n        return xy;\n    }\n\n    function getPageXY (pointer, page) {\n        page = page || {};\n\n        // Opera Mobile handles the viewport and scrolling oddly\n        if (isOperaMobile && isNativePointer(pointer)) {\n            getXY('screen', pointer, page);\n\n            page.x += window.scrollX;\n            page.y += window.scrollY;\n        }\n        else {\n            getXY('page', pointer, page);\n        }\n\n        return page;\n    }\n\n    function getClientXY (pointer, client) {\n        client = client || {};\n\n        if (isOperaMobile && isNativePointer(pointer)) {\n            // Opera Mobile handles the viewport and scrolling oddly\n            getXY('screen', pointer, client);\n        }\n        else {\n          getXY('client', pointer, client);\n        }\n\n        return client;\n    }\n\n    function getScrollXY (win) {\n        win = win || window;\n        return {\n            x: win.scrollX || win.document.documentElement.scrollLeft,\n            y: win.scrollY || win.document.documentElement.scrollTop\n        };\n    }\n\n    function getPointerId (pointer) {\n        return isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n    }\n\n    function getActualElement (element) {\n        return (element instanceof SVGElementInstance\n            ? element.correspondingUseElement\n            : element);\n    }\n\n    function getWindow (node) {\n        if (isWindow(node)) {\n            return node;\n        }\n\n        var rootNode = (node.ownerDocument || node);\n\n        return rootNode.defaultView || rootNode.parentWindow || window;\n    }\n\n    function getElementClientRect (element) {\n        var clientRect = (element instanceof SVGElement\n                            ? element.getBoundingClientRect()\n                            : element.getClientRects()[0]);\n\n        return clientRect && {\n            left  : clientRect.left,\n            right : clientRect.right,\n            top   : clientRect.top,\n            bottom: clientRect.bottom,\n            width : clientRect.width || clientRect.right - clientRect.left,\n            height: clientRect.height || clientRect.bottom - clientRect.top\n        };\n    }\n\n    function getElementRect (element) {\n        var clientRect = getElementClientRect(element);\n\n        if (!isIOS7 && clientRect) {\n            var scroll = getScrollXY(getWindow(element));\n\n            clientRect.left   += scroll.x;\n            clientRect.right  += scroll.x;\n            clientRect.top    += scroll.y;\n            clientRect.bottom += scroll.y;\n        }\n\n        return clientRect;\n    }\n\n    function getTouchPair (event) {\n        var touches = [];\n\n        // array of touches is supplied\n        if (isArray(event)) {\n            touches[0] = event[0];\n            touches[1] = event[1];\n        }\n        // an event\n        else {\n            if (event.type === 'touchend') {\n                if (event.touches.length === 1) {\n                    touches[0] = event.touches[0];\n                    touches[1] = event.changedTouches[0];\n                }\n                else if (event.touches.length === 0) {\n                    touches[0] = event.changedTouches[0];\n                    touches[1] = event.changedTouches[1];\n                }\n            }\n            else {\n                touches[0] = event.touches[0];\n                touches[1] = event.touches[1];\n            }\n        }\n\n        return touches;\n    }\n\n    function pointerAverage (pointers) {\n        var average = {\n            pageX  : 0,\n            pageY  : 0,\n            clientX: 0,\n            clientY: 0,\n            screenX: 0,\n            screenY: 0\n        };\n        var prop;\n\n        for (var i = 0; i < pointers.length; i++) {\n            for (prop in average) {\n                average[prop] += pointers[i][prop];\n            }\n        }\n        for (prop in average) {\n            average[prop] /= pointers.length;\n        }\n\n        return average;\n    }\n\n    function touchBBox (event) {\n        if (!event.length && !(event.touches && event.touches.length > 1)) {\n            return;\n        }\n\n        var touches = getTouchPair(event),\n            minX = Math.min(touches[0].pageX, touches[1].pageX),\n            minY = Math.min(touches[0].pageY, touches[1].pageY),\n            maxX = Math.max(touches[0].pageX, touches[1].pageX),\n            maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n        return {\n            x: minX,\n            y: minY,\n            left: minX,\n            top: minY,\n            width: maxX - minX,\n            height: maxY - minY\n        };\n    }\n\n    function touchDistance (event, deltaSource) {\n        deltaSource = deltaSource || defaultOptions.deltaSource;\n\n        var sourceX = deltaSource + 'X',\n            sourceY = deltaSource + 'Y',\n            touches = getTouchPair(event);\n\n\n        var dx = touches[0][sourceX] - touches[1][sourceX],\n            dy = touches[0][sourceY] - touches[1][sourceY];\n\n        return hypot(dx, dy);\n    }\n\n    function touchAngle (event, prevAngle, deltaSource) {\n        deltaSource = deltaSource || defaultOptions.deltaSource;\n\n        var sourceX = deltaSource + 'X',\n            sourceY = deltaSource + 'Y',\n            touches = getTouchPair(event),\n            dx = touches[0][sourceX] - touches[1][sourceX],\n            dy = touches[0][sourceY] - touches[1][sourceY],\n            angle = 180 * Math.atan(dy / dx) / Math.PI;\n\n        if (isNumber(prevAngle)) {\n            var dr = angle - prevAngle,\n                drClamped = dr % 360;\n\n            if (drClamped > 315) {\n                angle -= 360 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped > 135) {\n                angle -= 180 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped < -315) {\n                angle += 360 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped < -135) {\n                angle += 180 + (angle / 360)|0 * 360;\n            }\n        }\n\n        return  angle;\n    }\n\n    function getOriginXY (interactable, element) {\n        var origin = interactable\n                ? interactable.options.origin\n                : defaultOptions.origin;\n\n        if (origin === 'parent') {\n            origin = parentElement(element);\n        }\n        else if (origin === 'self') {\n            origin = interactable.getRect(element);\n        }\n        else if (trySelector(origin)) {\n            origin = closest(element, origin) || { x: 0, y: 0 };\n        }\n\n        if (isFunction(origin)) {\n            origin = origin(interactable && element);\n        }\n\n        if (isElement(origin))  {\n            origin = getElementRect(origin);\n        }\n\n        origin.x = ('x' in origin)? origin.x : origin.left;\n        origin.y = ('y' in origin)? origin.y : origin.top;\n\n        return origin;\n    }\n\n    // http://stackoverflow.com/a/5634528/2280888\n    function _getQBezierValue(t, p1, p2, p3) {\n        var iT = 1 - t;\n        return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n    }\n\n    function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n        return {\n            x:  _getQBezierValue(position, startX, cpX, endX),\n            y:  _getQBezierValue(position, startY, cpY, endY)\n        };\n    }\n\n    // http://gizma.com/easing/\n    function easeOutQuad (t, b, c, d) {\n        t /= d;\n        return -c * t*(t-2) + b;\n    }\n\n    function nodeContains (parent, child) {\n        while (child) {\n            if (child === parent) {\n                return true;\n            }\n\n            child = child.parentNode;\n        }\n\n        return false;\n    }\n\n    function closest (child, selector) {\n        var parent = parentElement(child);\n\n        while (isElement(parent)) {\n            if (matchesSelector(parent, selector)) { return parent; }\n\n            parent = parentElement(parent);\n        }\n\n        return null;\n    }\n\n    function parentElement (node) {\n        var parent = node.parentNode;\n\n        if (isDocFrag(parent)) {\n            // skip past #shado-root fragments\n            while ((parent = parent.host) && isDocFrag(parent)) {}\n\n            return parent;\n        }\n\n        return parent;\n    }\n\n    function inContext (interactable, element) {\n        return interactable._context === element.ownerDocument\n                || nodeContains(interactable._context, element);\n    }\n\n    function testIgnore (interactable, interactableElement, element) {\n        var ignoreFrom = interactable.options.ignoreFrom;\n\n        if (!ignoreFrom || !isElement(element)) { return false; }\n\n        if (isString(ignoreFrom)) {\n            return matchesUpTo(element, ignoreFrom, interactableElement);\n        }\n        else if (isElement(ignoreFrom)) {\n            return nodeContains(ignoreFrom, element);\n        }\n\n        return false;\n    }\n\n    function testAllow (interactable, interactableElement, element) {\n        var allowFrom = interactable.options.allowFrom;\n\n        if (!allowFrom) { return true; }\n\n        if (!isElement(element)) { return false; }\n\n        if (isString(allowFrom)) {\n            return matchesUpTo(element, allowFrom, interactableElement);\n        }\n        else if (isElement(allowFrom)) {\n            return nodeContains(allowFrom, element);\n        }\n\n        return false;\n    }\n\n    function checkAxis (axis, interactable) {\n        if (!interactable) { return false; }\n\n        var thisAxis = interactable.options.drag.axis;\n\n        return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n    }\n\n    function checkSnap (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return options[action].snap && options[action].snap.enabled;\n    }\n\n    function checkRestrict (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].restrict && options[action].restrict.enabled;\n    }\n\n    function checkAutoScroll (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].autoScroll && options[action].autoScroll.enabled;\n    }\n\n    function withinInteractionLimit (interactable, element, action) {\n        var options = interactable.options,\n            maxActions = options[action.name].max,\n            maxPerElement = options[action.name].maxPerElement,\n            activeInteractions = 0,\n            targetCount = 0,\n            targetElementCount = 0;\n\n        for (var i = 0, len = interactions.length; i < len; i++) {\n            var interaction = interactions[i],\n                otherAction = interaction.prepared.name,\n                active = interaction.interacting();\n\n            if (!active) { continue; }\n\n            activeInteractions++;\n\n            if (activeInteractions >= maxInteractions) {\n                return false;\n            }\n\n            if (interaction.target !== interactable) { continue; }\n\n            targetCount += (otherAction === action.name)|0;\n\n            if (targetCount >= maxActions) {\n                return false;\n            }\n\n            if (interaction.element === element) {\n                targetElementCount++;\n\n                if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n                    return false;\n                }\n            }\n        }\n\n        return maxInteractions > 0;\n    }\n\n    // Test for the element that's \"above\" all other qualifiers\n    function indexOfDeepestElement (elements) {\n        var dropzone,\n            deepestZone = elements[0],\n            index = deepestZone? 0: -1,\n            parent,\n            deepestZoneParents = [],\n            dropzoneParents = [],\n            child,\n            i,\n            n;\n\n        for (i = 1; i < elements.length; i++) {\n            dropzone = elements[i];\n\n            // an element might belong to multiple selector dropzones\n            if (!dropzone || dropzone === deepestZone) {\n                continue;\n            }\n\n            if (!deepestZone) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            // check if the deepest or current are document.documentElement or document.rootElement\n            // - if the current dropzone is, do nothing and continue\n            if (dropzone.parentNode === dropzone.ownerDocument) {\n                continue;\n            }\n            // - if deepest is, update with the current dropzone and continue to next\n            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            if (!deepestZoneParents.length) {\n                parent = deepestZone;\n                while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n                    deepestZoneParents.unshift(parent);\n                    parent = parent.parentNode;\n                }\n            }\n\n            // if this element is an svg element and the current deepest is\n            // an HTMLElement\n            if (deepestZone instanceof HTMLElement\n                && dropzone instanceof SVGElement\n                && !(dropzone instanceof SVGSVGElement)) {\n\n                if (dropzone === deepestZone.parentNode) {\n                    continue;\n                }\n\n                parent = dropzone.ownerSVGElement;\n            }\n            else {\n                parent = dropzone;\n            }\n\n            dropzoneParents = [];\n\n            while (parent.parentNode !== parent.ownerDocument) {\n                dropzoneParents.unshift(parent);\n                parent = parent.parentNode;\n            }\n\n            n = 0;\n\n            // get (position of last common ancestor) + 1\n            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n                n++;\n            }\n\n            var parents = [\n                dropzoneParents[n - 1],\n                dropzoneParents[n],\n                deepestZoneParents[n]\n            ];\n\n            child = parents[0].lastChild;\n\n            while (child) {\n                if (child === parents[1]) {\n                    deepestZone = dropzone;\n                    index = i;\n                    deepestZoneParents = [];\n\n                    break;\n                }\n                else if (child === parents[2]) {\n                    break;\n                }\n\n                child = child.previousSibling;\n            }\n        }\n\n        return index;\n    }\n\n    function Interaction () {\n        this.target          = null; // current interactable being interacted with\n        this.element         = null; // the target element of the interactable\n        this.dropTarget      = null; // the dropzone a drag target might be dropped into\n        this.dropElement     = null; // the element at the time of checking\n        this.prevDropTarget  = null; // the dropzone that was recently dragged away from\n        this.prevDropElement = null; // the element at the time of checking\n\n        this.prepared        = {     // action that's ready to be fired on next move event\n            name : null,\n            axis : null,\n            edges: null\n        };\n\n        this.matches         = [];   // all selectors that are matched by target element\n        this.matchElements   = [];   // corresponding elements\n\n        this.inertiaStatus = {\n            active       : false,\n            smoothEnd    : false,\n            ending       : false,\n\n            startEvent: null,\n            upCoords: {},\n\n            xe: 0, ye: 0,\n            sx: 0, sy: 0,\n\n            t0: 0,\n            vx0: 0, vys: 0,\n            duration: 0,\n\n            resumeDx: 0,\n            resumeDy: 0,\n\n            lambda_v0: 0,\n            one_ve_v0: 0,\n            i  : null\n        };\n\n        if (isFunction(Function.prototype.bind)) {\n            this.boundInertiaFrame = this.inertiaFrame.bind(this);\n            this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n        }\n        else {\n            var that = this;\n\n            this.boundInertiaFrame = function () { return that.inertiaFrame(); };\n            this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };\n        }\n\n        this.activeDrops = {\n            dropzones: [],      // the dropzones that are mentioned below\n            elements : [],      // elements of dropzones that accept the target draggable\n            rects    : []       // the rects of the elements mentioned above\n        };\n\n        // keep track of added pointers\n        this.pointers    = [];\n        this.pointerIds  = [];\n        this.downTargets = [];\n        this.downTimes   = [];\n        this.holdTimers  = [];\n\n        // Previous native pointer move event coordinates\n        this.prevCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n        // current native pointer move event coordinates\n        this.curCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n\n        // Starting InteractEvent pointer coordinates\n        this.startCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n\n        // Change in coordinates and time of the pointer\n        this.pointerDelta = {\n            page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n            client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n            timeStamp: 0\n        };\n\n        this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n        this.downPointer = {};\n\n        this._eventTarget    = null;\n        this._curEventTarget = null;\n\n        this.prevEvent = null;      // previous action event\n        this.tapTime   = 0;         // time of the most recent tap event\n        this.prevTap   = null;\n\n        this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };\n        this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n        this.snapOffsets    = [];\n\n        this.gesture = {\n            start: { x: 0, y: 0 },\n\n            startDistance: 0,   // distance between two touches of touchStart\n            prevDistance : 0,\n            distance     : 0,\n\n            scale: 1,           // gesture.distance / gesture.startDistance\n\n            startAngle: 0,      // angle of line joining two touches\n            prevAngle : 0       // angle of the previous gesture event\n        };\n\n        this.snapStatus = {\n            x       : 0, y       : 0,\n            dx      : 0, dy      : 0,\n            realX   : 0, realY   : 0,\n            snappedX: 0, snappedY: 0,\n            targets : [],\n            locked  : false,\n            changed : false\n        };\n\n        this.restrictStatus = {\n            dx         : 0, dy         : 0,\n            restrictedX: 0, restrictedY: 0,\n            snap       : null,\n            restricted : false,\n            changed    : false\n        };\n\n        this.restrictStatus.snap = this.snapStatus;\n\n        this.pointerIsDown   = false;\n        this.pointerWasMoved = false;\n        this.gesturing       = false;\n        this.dragging        = false;\n        this.resizing        = false;\n        this.resizeAxes      = 'xy';\n\n        this.mouse = false;\n\n        interactions.push(this);\n    }\n\n    Interaction.prototype = {\n        getPageXY  : function (pointer, xy) { return   getPageXY(pointer, xy, this); },\n        getClientXY: function (pointer, xy) { return getClientXY(pointer, xy, this); },\n        setEventXY : function (target, ptr) { return  setEventXY(target, ptr, this); },\n\n        pointerOver: function (pointer, event, eventTarget) {\n            if (this.prepared.name || !this.mouse) { return; }\n\n            var curMatches = [],\n                curMatchElements = [],\n                prevTargetElement = this.element;\n\n            this.addPointer(pointer);\n\n            if (this.target\n                && (testIgnore(this.target, this.element, eventTarget)\n                    || !testAllow(this.target, this.element, eventTarget))) {\n                // if the eventTarget should be ignored or shouldn't be allowed\n                // clear the previous target\n                this.target = null;\n                this.element = null;\n                this.matches = [];\n                this.matchElements = [];\n            }\n\n            var elementInteractable = interactables.get(eventTarget),\n                elementAction = (elementInteractable\n                                 && !testIgnore(elementInteractable, eventTarget, eventTarget)\n                                 && testAllow(elementInteractable, eventTarget, eventTarget)\n                                 && validateAction(\n                                     elementInteractable.getAction(pointer, event, this, eventTarget),\n                                     elementInteractable));\n\n            if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n                 elementAction = null;\n            }\n\n            function pushCurMatches (interactable, selector) {\n                if (interactable\n                    && inContext(interactable, eventTarget)\n                    && !testIgnore(interactable, eventTarget, eventTarget)\n                    && testAllow(interactable, eventTarget, eventTarget)\n                    && matchesSelector(eventTarget, selector)) {\n\n                    curMatches.push(interactable);\n                    curMatchElements.push(eventTarget);\n                }\n            }\n\n            if (elementAction) {\n                this.target = elementInteractable;\n                this.element = eventTarget;\n                this.matches = [];\n                this.matchElements = [];\n            }\n            else {\n                interactables.forEachSelector(pushCurMatches);\n\n                if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n                    this.matches = curMatches;\n                    this.matchElements = curMatchElements;\n\n                    this.pointerHover(pointer, event, this.matches, this.matchElements);\n                    events.add(eventTarget,\n                                        supportsPointerEvent? pEventTypes.move : 'mousemove',\n                                        listeners.pointerHover);\n                }\n                else if (this.target) {\n                    if (nodeContains(prevTargetElement, eventTarget)) {\n                        this.pointerHover(pointer, event, this.matches, this.matchElements);\n                        events.add(this.element,\n                                            supportsPointerEvent? pEventTypes.move : 'mousemove',\n                                            listeners.pointerHover);\n                    }\n                    else {\n                        this.target = null;\n                        this.element = null;\n                        this.matches = [];\n                        this.matchElements = [];\n                    }\n                }\n            }\n        },\n\n        // Check what action would be performed on pointerMove target if a mouse\n        // button were pressed and change the cursor accordingly\n        pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n            var target = this.target;\n\n            if (!this.prepared.name && this.mouse) {\n\n                var action;\n\n                // update pointer coords for defaultActionChecker to use\n                this.setEventXY(this.curCoords, [pointer]);\n\n                if (matches) {\n                    action = this.validateSelector(pointer, event, matches, matchElements);\n                }\n                else if (target) {\n                    action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n                }\n\n                if (target && target.options.styleCursor) {\n                    if (action) {\n                        target._doc.documentElement.style.cursor = getActionCursor(action);\n                    }\n                    else {\n                        target._doc.documentElement.style.cursor = '';\n                    }\n                }\n            }\n            else if (this.prepared.name) {\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n        },\n\n        pointerOut: function (pointer, event, eventTarget) {\n            if (this.prepared.name) { return; }\n\n            // Remove temporary event listeners for selector Interactables\n            if (!interactables.get(eventTarget)) {\n                events.remove(eventTarget,\n                                       supportsPointerEvent? pEventTypes.move : 'mousemove',\n                                       listeners.pointerHover);\n            }\n\n            if (this.target && this.target.options.styleCursor && !this.interacting()) {\n                this.target._doc.documentElement.style.cursor = '';\n            }\n        },\n\n        selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n            var that = this,\n                // copy event to be used in timeout for IE8\n                eventCopy = events.useAttachEvent? extend({}, event) : event,\n                element = eventTarget,\n                pointerIndex = this.addPointer(pointer),\n                action;\n\n            this.holdTimers[pointerIndex] = setTimeout(function () {\n                that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n            }, defaultOptions._holdDuration);\n\n            this.pointerIsDown = true;\n\n            // Check if the down event hits the current inertia target\n            if (this.inertiaStatus.active && this.target.selector) {\n                // climb up the DOM tree from the event target\n                while (isElement(element)) {\n\n                    // if this element is the current inertia target element\n                    if (element === this.element\n                        // and the prospective action is the same as the ongoing one\n                        && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\n                        // stop inertia so that the next move will be a normal one\n                        cancelFrame(this.inertiaStatus.i);\n                        this.inertiaStatus.active = false;\n\n                        this.collectEventTargets(pointer, event, eventTarget, 'down');\n                        return;\n                    }\n                    element = parentElement(element);\n                }\n            }\n\n            // do nothing if interacting\n            if (this.interacting()) {\n                this.collectEventTargets(pointer, event, eventTarget, 'down');\n                return;\n            }\n\n            function pushMatches (interactable, selector, context) {\n                var elements = ie8MatchesSelector\n                    ? context.querySelectorAll(selector)\n                    : undefined;\n\n                if (inContext(interactable, element)\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, elements)) {\n\n                    that.matches.push(interactable);\n                    that.matchElements.push(element);\n                }\n            }\n\n            // update pointer coords for defaultActionChecker to use\n            this.setEventXY(this.curCoords, [pointer]);\n            this.downEvent = event;\n\n            while (isElement(element) && !action) {\n                this.matches = [];\n                this.matchElements = [];\n\n                interactables.forEachSelector(pushMatches);\n\n                action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n                element = parentElement(element);\n            }\n\n            if (action) {\n                this.prepared.name  = action.name;\n                this.prepared.axis  = action.axis;\n                this.prepared.edges = action.edges;\n\n                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\n                return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n            }\n            else {\n                // do these now since pointerDown isn't being called from here\n                this.downTimes[pointerIndex] = new Date().getTime();\n                this.downTargets[pointerIndex] = eventTarget;\n                pointerExtend(this.downPointer, pointer);\n\n                copyCoords(this.prevCoords, this.curCoords);\n                this.pointerWasMoved = false;\n            }\n\n            this.collectEventTargets(pointer, event, eventTarget, 'down');\n        },\n\n        // Determine action to be performed on next pointerMove and add appropriate\n        // style and event Listeners\n        pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n            if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n                this.checkAndPreventDefault(event, this.target, this.element);\n\n                return;\n            }\n\n            this.pointerIsDown = true;\n            this.downEvent = event;\n\n            var pointerIndex = this.addPointer(pointer),\n                action;\n\n            // If it is the second touch of a multi-touch gesture, keep the\n            // target the same and get a new action if a target was set by the\n            // first touch\n            if (this.pointerIds.length > 1 && this.target._element === this.element) {\n                var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\n                if (withinInteractionLimit(this.target, this.element, newAction)) {\n                    action = newAction;\n                }\n\n                this.prepared.name = null;\n            }\n            // Otherwise, set the target if there is no action prepared\n            else if (!this.prepared.name) {\n                var interactable = interactables.get(curEventTarget);\n\n                if (interactable\n                    && !testIgnore(interactable, curEventTarget, eventTarget)\n                    && testAllow(interactable, curEventTarget, eventTarget)\n                    && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n                    && withinInteractionLimit(interactable, curEventTarget, action)) {\n                    this.target = interactable;\n                    this.element = curEventTarget;\n                }\n            }\n\n            var target = this.target,\n                options = target && target.options;\n\n            if (target && (forceAction || !this.prepared.name)) {\n                action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\n                this.setEventXY(this.startCoords, this.pointers);\n\n                if (!action) { return; }\n\n                if (options.styleCursor) {\n                    target._doc.documentElement.style.cursor = getActionCursor(action);\n                }\n\n                this.resizeAxes = action.name === 'resize'? action.axis : null;\n\n                if (action === 'gesture' && this.pointerIds.length < 2) {\n                    action = null;\n                }\n\n                this.prepared.name  = action.name;\n                this.prepared.axis  = action.axis;\n                this.prepared.edges = action.edges;\n\n                this.snapStatus.snappedX = this.snapStatus.snappedY =\n                    this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\n                this.downTimes[pointerIndex] = new Date().getTime();\n                this.downTargets[pointerIndex] = eventTarget;\n                pointerExtend(this.downPointer, pointer);\n\n                copyCoords(this.prevCoords, this.startCoords);\n                this.pointerWasMoved = false;\n\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n            // if inertia is active try to resume action\n            else if (this.inertiaStatus.active\n                && curEventTarget === this.element\n                && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\n                cancelFrame(this.inertiaStatus.i);\n                this.inertiaStatus.active = false;\n\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n        },\n\n        setModifications: function (coords, preEnd) {\n            var target         = this.target,\n                shouldMove     = true,\n                shouldSnap     = checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),\n                shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\n            if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }\n            if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }\n\n            if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n                shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n            }\n            else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n                shouldMove = false;\n            }\n\n            return shouldMove;\n        },\n\n        setStartOffsets: function (action, interactable, element) {\n            var rect = interactable.getRect(element),\n                origin = getOriginXY(interactable, element),\n                snap = interactable.options[this.prepared.name].snap,\n                restrict = interactable.options[this.prepared.name].restrict,\n                width, height;\n\n            if (rect) {\n                this.startOffset.left = this.startCoords.page.x - rect.left;\n                this.startOffset.top  = this.startCoords.page.y - rect.top;\n\n                this.startOffset.right  = rect.right  - this.startCoords.page.x;\n                this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n                if ('width' in rect) { width = rect.width; }\n                else { width = rect.right - rect.left; }\n                if ('height' in rect) { height = rect.height; }\n                else { height = rect.bottom - rect.top; }\n            }\n            else {\n                this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n            }\n\n            this.snapOffsets.splice(0);\n\n            var snapOffset = snap && snap.offset === 'startCoords'\n                                ? {\n                                    x: this.startCoords.page.x - origin.x,\n                                    y: this.startCoords.page.y - origin.y\n                                }\n                                : snap && snap.offset || { x: 0, y: 0 };\n\n            if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n                for (var i = 0; i < snap.relativePoints.length; i++) {\n                    this.snapOffsets.push({\n                        x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,\n                        y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y\n                    });\n                }\n            }\n            else {\n                this.snapOffsets.push(snapOffset);\n            }\n\n            if (rect && restrict.elementRect) {\n                this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);\n                this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);\n\n                this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));\n                this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));\n            }\n            else {\n                this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n            }\n        },\n\n        /*\\\n         * Interaction.start\n         [ method ]\n         *\n         * Start an action with the given Interactable and Element as tartgets. The\n         * action must be enabled for the target Interactable and an appropriate number\n         * of pointers must be held down – 1 for drag/resize, 2 for gesture.\n         *\n         * Use it with `interactable.<action>able({ manualStart: false })` to always\n         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n         *\n         - action       (object)  The action to be performed - drag, resize, etc.\n         - interactable (Interactable) The Interactable to target\n         - element      (Element) The DOM Element to target\n         = (object) interact\n         **\n         | interact(target)\n         |   .draggable({\n         |     // disable the default drag start by down->move\n         |     manualStart: true\n         |   })\n         |   // start dragging after the user holds the pointer down\n         |   .on('hold', function (event) {\n         |     var interaction = event.interaction;\n         |\n         |     if (!interaction.interacting()) {\n         |       interaction.start({ name: 'drag' },\n         |                         event.interactable,\n         |                         event.currentTarget);\n         |     }\n         | });\n        \\*/\n        start: function (action, interactable, element) {\n            if (this.interacting()\n                || !this.pointerIsDown\n                || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n                return;\n            }\n\n            // if this interaction had been removed after stopping\n            // add it back\n            if (indexOf(interactions, this) === -1) {\n                interactions.push(this);\n            }\n\n            // set the startCoords if there was no prepared action\n            if (!this.prepared.name) {\n                this.setEventXY(this.startCoords, this.pointers);\n            }\n\n            this.prepared.name  = action.name;\n            this.prepared.axis  = action.axis;\n            this.prepared.edges = action.edges;\n            this.target         = interactable;\n            this.element        = element;\n\n            this.setStartOffsets(action.name, interactable, element);\n            this.setModifications(this.startCoords.page);\n\n            this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n        },\n\n        pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n            if (this.inertiaStatus.active) {\n                var pageUp   = this.inertiaStatus.upCoords.page;\n                var clientUp = this.inertiaStatus.upCoords.client;\n\n                var inertiaPosition = {\n                    pageX  : pageUp.x   + this.inertiaStatus.sx,\n                    pageY  : pageUp.y   + this.inertiaStatus.sy,\n                    clientX: clientUp.x + this.inertiaStatus.sx,\n                    clientY: clientUp.y + this.inertiaStatus.sy\n                };\n\n                this.setEventXY(this.curCoords, [inertiaPosition]);\n            }\n            else {\n                this.recordPointer(pointer);\n                this.setEventXY(this.curCoords, this.pointers);\n            }\n\n            var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n                                 && this.curCoords.page.y === this.prevCoords.page.y\n                                 && this.curCoords.client.x === this.prevCoords.client.x\n                                 && this.curCoords.client.y === this.prevCoords.client.y);\n\n            var dx, dy,\n                pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            // register movement greater than pointerMoveTolerance\n            if (this.pointerIsDown && !this.pointerWasMoved) {\n                dx = this.curCoords.client.x - this.startCoords.client.x;\n                dy = this.curCoords.client.y - this.startCoords.client.y;\n\n                this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n            }\n\n            if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n                if (this.pointerIsDown) {\n                    clearTimeout(this.holdTimers[pointerIndex]);\n                }\n\n                this.collectEventTargets(pointer, event, eventTarget, 'move');\n            }\n\n            if (!this.pointerIsDown) { return; }\n\n            if (duplicateMove && this.pointerWasMoved && !preEnd) {\n                this.checkAndPreventDefault(event, this.target, this.element);\n                return;\n            }\n\n            // set pointer coordinate, time changes and speeds\n            setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n            if (!this.prepared.name) { return; }\n\n            if (this.pointerWasMoved\n                // ignore movement while inertia is active\n                && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\n                // if just starting an action, calculate the pointer speed now\n                if (!this.interacting()) {\n                    setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n                    // check if a drag is in the correct axis\n                    if (this.prepared.name === 'drag') {\n                        var absX = Math.abs(dx),\n                            absY = Math.abs(dy),\n                            targetAxis = this.target.options.drag.axis,\n                            axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n                        // if the movement isn't in the axis of the interactable\n                        if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n                            // cancel the prepared action\n                            this.prepared.name = null;\n\n                            // then try to get a drag from another ineractable\n\n                            var element = eventTarget;\n\n                            // check element interactables\n                            while (isElement(element)) {\n                                var elementInteractable = interactables.get(element);\n\n                                if (elementInteractable\n                                    && elementInteractable !== this.target\n                                    && !elementInteractable.options.drag.manualStart\n                                    && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag'\n                                    && checkAxis(axis, elementInteractable)) {\n\n                                    this.prepared.name = 'drag';\n                                    this.target = elementInteractable;\n                                    this.element = element;\n                                    break;\n                                }\n\n                                element = parentElement(element);\n                            }\n\n                            // if there's no drag from element interactables,\n                            // check the selector interactables\n                            if (!this.prepared.name) {\n                                var thisInteraction = this;\n\n                                var getDraggable = function (interactable, selector, context) {\n                                    var elements = ie8MatchesSelector\n                                        ? context.querySelectorAll(selector)\n                                        : undefined;\n\n                                    if (interactable === thisInteraction.target) { return; }\n\n                                    if (inContext(interactable, eventTarget)\n                                        && !interactable.options.drag.manualStart\n                                        && !testIgnore(interactable, element, eventTarget)\n                                        && testAllow(interactable, element, eventTarget)\n                                        && matchesSelector(element, selector, elements)\n                                        && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'\n                                        && checkAxis(axis, interactable)\n                                        && withinInteractionLimit(interactable, element, 'drag')) {\n\n                                        return interactable;\n                                    }\n                                };\n\n                                element = eventTarget;\n\n                                while (isElement(element)) {\n                                    var selectorInteractable = interactables.forEachSelector(getDraggable);\n\n                                    if (selectorInteractable) {\n                                        this.prepared.name = 'drag';\n                                        this.target = selectorInteractable;\n                                        this.element = element;\n                                        break;\n                                    }\n\n                                    element = parentElement(element);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                var starting = !!this.prepared.name && !this.interacting();\n\n                if (starting\n                    && (this.target.options[this.prepared.name].manualStart\n                        || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n                    this.stop(event);\n                    return;\n                }\n\n                if (this.prepared.name && this.target) {\n                    if (starting) {\n                        this.start(this.prepared, this.target, this.element);\n                    }\n\n                    var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\n                    // move if snapping or restriction doesn't prevent it\n                    if (shouldMove || starting) {\n                        this.prevEvent = this[this.prepared.name + 'Move'](event);\n                    }\n\n                    this.checkAndPreventDefault(event, this.target, this.element);\n                }\n            }\n\n            copyCoords(this.prevCoords, this.curCoords);\n\n            if (this.dragging || this.resizing) {\n                this.autoScrollMove(pointer);\n            }\n        },\n\n        dragStart: function (event) {\n            var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\n            this.dragging = true;\n            this.target.fire(dragEvent);\n\n            // reset active dropzones\n            this.activeDrops.dropzones = [];\n            this.activeDrops.elements  = [];\n            this.activeDrops.rects     = [];\n\n            if (!this.dynamicDrop) {\n                this.setActiveDrops(this.element);\n            }\n\n            var dropEvents = this.getDropEvents(event, dragEvent);\n\n            if (dropEvents.activate) {\n                this.fireActiveDrops(dropEvents.activate);\n            }\n\n            return dragEvent;\n        },\n\n        dragMove: function (event) {\n            var target = this.target,\n                dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),\n                draggableElement = this.element,\n                drop = this.getDrop(dragEvent, event, draggableElement);\n\n            this.dropTarget = drop.dropzone;\n            this.dropElement = drop.element;\n\n            var dropEvents = this.getDropEvents(event, dragEvent);\n\n            target.fire(dragEvent);\n\n            if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n            if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n            if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }\n\n            this.prevDropTarget  = this.dropTarget;\n            this.prevDropElement = this.dropElement;\n\n            return dragEvent;\n        },\n\n        resizeStart: function (event) {\n            var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\n            if (this.prepared.edges) {\n                var startRect = this.target.getRect(this.element);\n\n                /*\n                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n                 * on the active edges and the edge being interacted with.\n                 */\n                if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n                    var linkedEdges = extend({}, this.prepared.edges);\n\n                    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n                    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n                    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n                    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n                    this.prepared._linkedEdges = linkedEdges;\n                }\n                else {\n                    this.prepared._linkedEdges = null;\n                }\n\n                // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n                if (this.target.options.resize.preserveAspectRatio) {\n                    this.resizeStartAspectRatio = startRect.width / startRect.height;\n                }\n\n                this.resizeRects = {\n                    start     : startRect,\n                    current   : extend({}, startRect),\n                    restricted: extend({}, startRect),\n                    previous  : extend({}, startRect),\n                    delta     : {\n                        left: 0, right : 0, width : 0,\n                        top : 0, bottom: 0, height: 0\n                    }\n                };\n\n                resizeEvent.rect = this.resizeRects.restricted;\n                resizeEvent.deltaRect = this.resizeRects.delta;\n            }\n\n            this.target.fire(resizeEvent);\n\n            this.resizing = true;\n\n            return resizeEvent;\n        },\n\n        resizeMove: function (event) {\n            var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\n            var edges = this.prepared.edges,\n                invert = this.target.options.resize.invert,\n                invertible = invert === 'reposition' || invert === 'negate';\n\n            if (edges) {\n                var dx = resizeEvent.dx,\n                    dy = resizeEvent.dy,\n\n                    start      = this.resizeRects.start,\n                    current    = this.resizeRects.current,\n                    restricted = this.resizeRects.restricted,\n                    delta      = this.resizeRects.delta,\n                    previous   = extend(this.resizeRects.previous, restricted),\n\n                    originalEdges = edges;\n\n                // `resize.preserveAspectRatio` takes precedence over `resize.square`\n                if (this.target.options.resize.preserveAspectRatio) {\n                    var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\n                    edges = this.prepared._linkedEdges;\n\n                    if ((originalEdges.left && originalEdges.bottom)\n                        || (originalEdges.right && originalEdges.top)) {\n                        dy = -dx / resizeStartAspectRatio;\n                    }\n                    else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }\n                    else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }\n                }\n                else if (this.target.options.resize.square) {\n                    edges = this.prepared._linkedEdges;\n\n                    if ((originalEdges.left && originalEdges.bottom)\n                        || (originalEdges.right && originalEdges.top)) {\n                        dy = -dx;\n                    }\n                    else if (originalEdges.left || originalEdges.right) { dy = dx; }\n                    else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n                }\n\n                // update the 'current' rect without modifications\n                if (edges.top   ) { current.top    += dy; }\n                if (edges.bottom) { current.bottom += dy; }\n                if (edges.left  ) { current.left   += dx; }\n                if (edges.right ) { current.right  += dx; }\n\n                if (invertible) {\n                    // if invertible, copy the current rect\n                    extend(restricted, current);\n\n                    if (invert === 'reposition') {\n                        // swap edge values if necessary to keep width/height positive\n                        var swap;\n\n                        if (restricted.top > restricted.bottom) {\n                            swap = restricted.top;\n\n                            restricted.top = restricted.bottom;\n                            restricted.bottom = swap;\n                        }\n                        if (restricted.left > restricted.right) {\n                            swap = restricted.left;\n\n                            restricted.left = restricted.right;\n                            restricted.right = swap;\n                        }\n                    }\n                }\n                else {\n                    // if not invertible, restrict to minimum of 0x0 rect\n                    restricted.top    = Math.min(current.top, start.bottom);\n                    restricted.bottom = Math.max(current.bottom, start.top);\n                    restricted.left   = Math.min(current.left, start.right);\n                    restricted.right  = Math.max(current.right, start.left);\n                }\n\n                restricted.width  = restricted.right  - restricted.left;\n                restricted.height = restricted.bottom - restricted.top ;\n\n                for (var edge in restricted) {\n                    delta[edge] = restricted[edge] - previous[edge];\n                }\n\n                resizeEvent.edges = this.prepared.edges;\n                resizeEvent.rect = restricted;\n                resizeEvent.deltaRect = delta;\n            }\n\n            this.target.fire(resizeEvent);\n\n            return resizeEvent;\n        },\n\n        gestureStart: function (event) {\n            var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\n            gestureEvent.ds = 0;\n\n            this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n            this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n            this.gesture.scale = 1;\n\n            this.gesturing = true;\n\n            this.target.fire(gestureEvent);\n\n            return gestureEvent;\n        },\n\n        gestureMove: function (event) {\n            if (!this.pointerIds.length) {\n                return this.prevEvent;\n            }\n\n            var gestureEvent;\n\n            gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n            gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\n            this.target.fire(gestureEvent);\n\n            this.gesture.prevAngle = gestureEvent.angle;\n            this.gesture.prevDistance = gestureEvent.distance;\n\n            if (gestureEvent.scale !== Infinity &&\n                gestureEvent.scale !== null &&\n                gestureEvent.scale !== undefined  &&\n                !isNaN(gestureEvent.scale)) {\n\n                this.gesture.scale = gestureEvent.scale;\n            }\n\n            return gestureEvent;\n        },\n\n        pointerHold: function (pointer, event, eventTarget) {\n            this.collectEventTargets(pointer, event, eventTarget, 'hold');\n        },\n\n        pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            clearTimeout(this.holdTimers[pointerIndex]);\n\n            this.collectEventTargets(pointer, event, eventTarget, 'up' );\n            this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\n            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n            this.removePointer(pointer);\n        },\n\n        pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            clearTimeout(this.holdTimers[pointerIndex]);\n\n            this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n            this.removePointer(pointer);\n        },\n\n        // http://www.quirksmode.org/dom/events/click.html\n        // >Events leading to dblclick\n        //\n        // IE8 doesn't fire down event before dblclick.\n        // This workaround tries to fire a tap and doubletap after dblclick\n        ie8Dblclick: function (pointer, event, eventTarget) {\n            if (this.prevTap\n                && event.clientX === this.prevTap.clientX\n                && event.clientY === this.prevTap.clientY\n                && eventTarget   === this.prevTap.target) {\n\n                this.downTargets[0] = eventTarget;\n                this.downTimes[0] = new Date().getTime();\n                this.collectEventTargets(pointer, event, eventTarget, 'tap');\n            }\n        },\n\n        // End interact move events and stop auto-scroll unless inertia is enabled\n        pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n            var endEvent,\n                target = this.target,\n                options = target && target.options,\n                inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n                inertiaStatus = this.inertiaStatus;\n\n            if (this.interacting()) {\n\n                if (inertiaStatus.active && !inertiaStatus.ending) { return; }\n\n                var pointerSpeed,\n                    now = new Date().getTime(),\n                    inertiaPossible = false,\n                    inertia = false,\n                    smoothEnd = false,\n                    endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n                    endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n                    dx = 0,\n                    dy = 0,\n                    startEvent;\n\n                if (this.dragging) {\n                    if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n                    else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n                    else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n                }\n                else {\n                    pointerSpeed = this.pointerDelta.client.speed;\n                }\n\n                // check if inertia should be started\n                inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n                                   && this.prepared.name !== 'gesture'\n                                   && event !== inertiaStatus.startEvent);\n\n                inertia = (inertiaPossible\n                           && (now - this.curCoords.timeStamp) < 50\n                           && pointerSpeed > inertiaOptions.minSpeed\n                           && pointerSpeed > inertiaOptions.endSpeed);\n\n                if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\n                    var snapRestrict = {};\n\n                    snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\n                    if (endSnap) {\n                        this.setSnapping(this.curCoords.page, snapRestrict);\n                        if (snapRestrict.locked) {\n                            dx += snapRestrict.dx;\n                            dy += snapRestrict.dy;\n                        }\n                    }\n\n                    if (endRestrict) {\n                        this.setRestriction(this.curCoords.page, snapRestrict);\n                        if (snapRestrict.restricted) {\n                            dx += snapRestrict.dx;\n                            dy += snapRestrict.dy;\n                        }\n                    }\n\n                    if (dx || dy) {\n                        smoothEnd = true;\n                    }\n                }\n\n                if (inertia || smoothEnd) {\n                    copyCoords(inertiaStatus.upCoords, this.curCoords);\n\n                    this.pointers[0] = inertiaStatus.startEvent = startEvent =\n                        new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\n                    inertiaStatus.t0 = now;\n\n                    target.fire(inertiaStatus.startEvent);\n\n                    if (inertia) {\n                        inertiaStatus.vx0 = this.pointerDelta.client.vx;\n                        inertiaStatus.vy0 = this.pointerDelta.client.vy;\n                        inertiaStatus.v0 = pointerSpeed;\n\n                        this.calcInertia(inertiaStatus);\n\n                        var page = extend({}, this.curCoords.page),\n                            origin = getOriginXY(target, this.element),\n                            statusObject;\n\n                        page.x = page.x + inertiaStatus.xe - origin.x;\n                        page.y = page.y + inertiaStatus.ye - origin.y;\n\n                        statusObject = {\n                            useStatusXY: true,\n                            x: page.x,\n                            y: page.y,\n                            dx: 0,\n                            dy: 0,\n                            snap: null\n                        };\n\n                        statusObject.snap = statusObject;\n\n                        dx = dy = 0;\n\n                        if (endSnap) {\n                            var snap = this.setSnapping(this.curCoords.page, statusObject);\n\n                            if (snap.locked) {\n                                dx += snap.dx;\n                                dy += snap.dy;\n                            }\n                        }\n\n                        if (endRestrict) {\n                            var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\n                            if (restrict.restricted) {\n                                dx += restrict.dx;\n                                dy += restrict.dy;\n                            }\n                        }\n\n                        inertiaStatus.modifiedXe += dx;\n                        inertiaStatus.modifiedYe += dy;\n\n                        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n                    }\n                    else {\n                        inertiaStatus.smoothEnd = true;\n                        inertiaStatus.xe = dx;\n                        inertiaStatus.ye = dy;\n\n                        inertiaStatus.sx = inertiaStatus.sy = 0;\n\n                        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n                    }\n\n                    inertiaStatus.active = true;\n                    return;\n                }\n\n                if (endSnap || endRestrict) {\n                    // fire a move event at the snapped coordinates\n                    this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n                }\n            }\n\n            if (this.dragging) {\n                endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\n                var draggableElement = this.element,\n                    drop = this.getDrop(endEvent, event, draggableElement);\n\n                this.dropTarget = drop.dropzone;\n                this.dropElement = drop.element;\n\n                var dropEvents = this.getDropEvents(event, endEvent);\n\n                if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n                if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n                if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }\n                if (dropEvents.deactivate) {\n                    this.fireActiveDrops(dropEvents.deactivate);\n                }\n\n                target.fire(endEvent);\n            }\n            else if (this.resizing) {\n                endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n                target.fire(endEvent);\n            }\n            else if (this.gesturing) {\n                endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n                target.fire(endEvent);\n            }\n\n            this.stop(event);\n        },\n\n        collectDrops: function (element) {\n            var drops = [],\n                elements = [],\n                i;\n\n            element = element || this.element;\n\n            // collect all dropzones and their elements which qualify for a drop\n            for (i = 0; i < interactables.length; i++) {\n                if (!interactables[i].options.drop.enabled) { continue; }\n\n                var current = interactables[i],\n                    accept = current.options.drop.accept;\n\n                // test the draggable element against the dropzone's accept setting\n                if ((isElement(accept) && accept !== element)\n                    || (isString(accept)\n                        && !matchesSelector(element, accept))) {\n\n                    continue;\n                }\n\n                // query for new elements if necessary\n                var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];\n\n                for (var j = 0, len = dropElements.length; j < len; j++) {\n                    var currentElement = dropElements[j];\n\n                    if (currentElement === element) {\n                        continue;\n                    }\n\n                    drops.push(current);\n                    elements.push(currentElement);\n                }\n            }\n\n            return {\n                dropzones: drops,\n                elements: elements\n            };\n        },\n\n        fireActiveDrops: function (event) {\n            var i,\n                current,\n                currentElement,\n                prevElement;\n\n            // loop through all active dropzones and trigger event\n            for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n                current = this.activeDrops.dropzones[i];\n                currentElement = this.activeDrops.elements [i];\n\n                // prevent trigger of duplicate events on same element\n                if (currentElement !== prevElement) {\n                    // set current element as event target\n                    event.target = currentElement;\n                    current.fire(event);\n                }\n                prevElement = currentElement;\n            }\n        },\n\n        // Collect a new set of possible drops and save them in activeDrops.\n        // setActiveDrops should always be called when a drag has just started or a\n        // drag event happens while dynamicDrop is true\n        setActiveDrops: function (dragElement) {\n            // get dropzones and their elements that could receive the draggable\n            var possibleDrops = this.collectDrops(dragElement, true);\n\n            this.activeDrops.dropzones = possibleDrops.dropzones;\n            this.activeDrops.elements  = possibleDrops.elements;\n            this.activeDrops.rects     = [];\n\n            for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n                this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n            }\n        },\n\n        getDrop: function (dragEvent, event, dragElement) {\n            var validDrops = [];\n\n            if (dynamicDrop) {\n                this.setActiveDrops(dragElement);\n            }\n\n            // collect all dropzones and their elements which qualify for a drop\n            for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n                var current        = this.activeDrops.dropzones[j],\n                    currentElement = this.activeDrops.elements [j],\n                    rect           = this.activeDrops.rects    [j];\n\n                validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect)\n                                ? currentElement\n                                : null);\n            }\n\n            // get the most appropriate dropzone based on DOM depth and order\n            var dropIndex = indexOfDeepestElement(validDrops),\n                dropzone  = this.activeDrops.dropzones[dropIndex] || null,\n                element   = this.activeDrops.elements [dropIndex] || null;\n\n            return {\n                dropzone: dropzone,\n                element: element\n            };\n        },\n\n        getDropEvents: function (pointerEvent, dragEvent) {\n            var dropEvents = {\n                enter     : null,\n                leave     : null,\n                activate  : null,\n                deactivate: null,\n                move      : null,\n                drop      : null\n            };\n\n            if (this.dropElement !== this.prevDropElement) {\n                // if there was a prevDropTarget, create a dragleave event\n                if (this.prevDropTarget) {\n                    dropEvents.leave = {\n                        target       : this.prevDropElement,\n                        dropzone     : this.prevDropTarget,\n                        relatedTarget: dragEvent.target,\n                        draggable    : dragEvent.interactable,\n                        dragEvent    : dragEvent,\n                        interaction  : this,\n                        timeStamp    : dragEvent.timeStamp,\n                        type         : 'dragleave'\n                    };\n\n                    dragEvent.dragLeave = this.prevDropElement;\n                    dragEvent.prevDropzone = this.prevDropTarget;\n                }\n                // if the dropTarget is not null, create a dragenter event\n                if (this.dropTarget) {\n                    dropEvents.enter = {\n                        target       : this.dropElement,\n                        dropzone     : this.dropTarget,\n                        relatedTarget: dragEvent.target,\n                        draggable    : dragEvent.interactable,\n                        dragEvent    : dragEvent,\n                        interaction  : this,\n                        timeStamp    : dragEvent.timeStamp,\n                        type         : 'dragenter'\n                    };\n\n                    dragEvent.dragEnter = this.dropElement;\n                    dragEvent.dropzone = this.dropTarget;\n                }\n            }\n\n            if (dragEvent.type === 'dragend' && this.dropTarget) {\n                dropEvents.drop = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'drop'\n                };\n\n                dragEvent.dropzone = this.dropTarget;\n            }\n            if (dragEvent.type === 'dragstart') {\n                dropEvents.activate = {\n                    target       : null,\n                    dropzone     : null,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropactivate'\n                };\n            }\n            if (dragEvent.type === 'dragend') {\n                dropEvents.deactivate = {\n                    target       : null,\n                    dropzone     : null,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropdeactivate'\n                };\n            }\n            if (dragEvent.type === 'dragmove' && this.dropTarget) {\n                dropEvents.move = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    dragmove     : dragEvent,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropmove'\n                };\n                dragEvent.dropzone = this.dropTarget;\n            }\n\n            return dropEvents;\n        },\n\n        currentAction: function () {\n            return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;\n        },\n\n        interacting: function () {\n            return this.dragging || this.resizing || this.gesturing;\n        },\n\n        clearTargets: function () {\n            this.target = this.element = null;\n\n            this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n        },\n\n        stop: function (event) {\n            if (this.interacting()) {\n                autoScroll.stop();\n                this.matches = [];\n                this.matchElements = [];\n\n                var target = this.target;\n\n                if (target.options.styleCursor) {\n                    target._doc.documentElement.style.cursor = '';\n                }\n\n                // prevent Default only if were previously interacting\n                if (event && isFunction(event.preventDefault)) {\n                    this.checkAndPreventDefault(event, target, this.element);\n                }\n\n                if (this.dragging) {\n                    this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n                }\n            }\n\n            this.clearTargets();\n\n            this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n            this.prepared.name = this.prevEvent = null;\n            this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\n            // remove pointers if their ID isn't in this.pointerIds\n            for (var i = 0; i < this.pointers.length; i++) {\n                if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n                    this.pointers.splice(i, 1);\n                }\n            }\n        },\n\n        inertiaFrame: function () {\n            var inertiaStatus = this.inertiaStatus,\n                options = this.target.options[this.prepared.name].inertia,\n                lambda = options.resistance,\n                t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n            if (t < inertiaStatus.te) {\n\n                var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\n                if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n                    inertiaStatus.sx = inertiaStatus.xe * progress;\n                    inertiaStatus.sy = inertiaStatus.ye * progress;\n                }\n                else {\n                    var quadPoint = getQuadraticCurvePoint(\n                            0, 0,\n                            inertiaStatus.xe, inertiaStatus.ye,\n                            inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,\n                            progress);\n\n                    inertiaStatus.sx = quadPoint.x;\n                    inertiaStatus.sy = quadPoint.y;\n                }\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n            }\n            else {\n                inertiaStatus.ending = true;\n\n                inertiaStatus.sx = inertiaStatus.modifiedXe;\n                inertiaStatus.sy = inertiaStatus.modifiedYe;\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.active = inertiaStatus.ending = false;\n            }\n        },\n\n        smoothEndFrame: function () {\n            var inertiaStatus = this.inertiaStatus,\n                t = new Date().getTime() - inertiaStatus.t0,\n                duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n            if (t < duration) {\n                inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n                inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n            }\n            else {\n                inertiaStatus.ending = true;\n\n                inertiaStatus.sx = inertiaStatus.xe;\n                inertiaStatus.sy = inertiaStatus.ye;\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.smoothEnd =\n                  inertiaStatus.active = inertiaStatus.ending = false;\n            }\n        },\n\n        addPointer: function (pointer) {\n            var id = getPointerId(pointer),\n                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n            if (index === -1) {\n                index = this.pointerIds.length;\n            }\n\n            this.pointerIds[index] = id;\n            this.pointers[index] = pointer;\n\n            return index;\n        },\n\n        removePointer: function (pointer) {\n            var id = getPointerId(pointer),\n                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n            if (index === -1) { return; }\n\n            this.pointers   .splice(index, 1);\n            this.pointerIds .splice(index, 1);\n            this.downTargets.splice(index, 1);\n            this.downTimes  .splice(index, 1);\n            this.holdTimers .splice(index, 1);\n        },\n\n        recordPointer: function (pointer) {\n            var index = this.mouse? 0: indexOf(this.pointerIds, getPointerId(pointer));\n\n            if (index === -1) { return; }\n\n            this.pointers[index] = pointer;\n        },\n\n        collectEventTargets: function (pointer, event, eventTarget, eventType) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            // do not fire a tap event if the pointer was moved before being lifted\n            if (eventType === 'tap' && (this.pointerWasMoved\n                // or if the pointerup target is different to the pointerdown target\n                || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n                return;\n            }\n\n            var targets = [],\n                elements = [],\n                element = eventTarget;\n\n            function collectSelectors (interactable, selector, context) {\n                var els = ie8MatchesSelector\n                        ? context.querySelectorAll(selector)\n                        : undefined;\n\n                if (interactable._iEvents[eventType]\n                    && isElement(element)\n                    && inContext(interactable, element)\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, els)) {\n\n                    targets.push(interactable);\n                    elements.push(element);\n                }\n            }\n\n            while (element) {\n                if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n                    targets.push(interact(element));\n                    elements.push(element);\n                }\n\n                interactables.forEachSelector(collectSelectors);\n\n                element = parentElement(element);\n            }\n\n            // create the tap event even if there are no listeners so that\n            // doubletap can still be created and fired\n            if (targets.length || eventType === 'tap') {\n                this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n            }\n        },\n\n        firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n                pointerEvent = {},\n                i,\n                // for tap events\n                interval, createNewDoubleTap;\n\n            // if it's a doubletap then the event properties would have been\n            // copied from the tap event and provided as the pointer argument\n            if (eventType === 'doubletap') {\n                pointerEvent = pointer;\n            }\n            else {\n                pointerExtend(pointerEvent, event);\n                if (event !== pointer) {\n                    pointerExtend(pointerEvent, pointer);\n                }\n\n                pointerEvent.preventDefault           = preventOriginalDefault;\n                pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n                pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n                pointerEvent.interaction              = this;\n\n                pointerEvent.timeStamp       = new Date().getTime();\n                pointerEvent.originalEvent   = event;\n                pointerEvent.originalPointer = pointer;\n                pointerEvent.type            = eventType;\n                pointerEvent.pointerId       = getPointerId(pointer);\n                pointerEvent.pointerType     = this.mouse? 'mouse' : !supportsPointerEvent? 'touch'\n                                                    : isString(pointer.pointerType)\n                                                        ? pointer.pointerType\n                                                        : [,,'touch', 'pen', 'mouse'][pointer.pointerType];\n            }\n\n            if (eventType === 'tap') {\n                pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\n                interval = pointerEvent.timeStamp - this.tapTime;\n                createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'\n                       && this.prevTap.target === pointerEvent.target\n                       && interval < 500);\n\n                pointerEvent.double = createNewDoubleTap;\n\n                this.tapTime = pointerEvent.timeStamp;\n            }\n\n            for (i = 0; i < targets.length; i++) {\n                pointerEvent.currentTarget = elements[i];\n                pointerEvent.interactable = targets[i];\n                targets[i].fire(pointerEvent);\n\n                if (pointerEvent.immediatePropagationStopped\n                    ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {\n                    break;\n                }\n            }\n\n            if (createNewDoubleTap) {\n                var doubleTap = {};\n\n                extend(doubleTap, pointerEvent);\n\n                doubleTap.dt   = interval;\n                doubleTap.type = 'doubletap';\n\n                this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\n                this.prevTap = doubleTap;\n            }\n            else if (eventType === 'tap') {\n                this.prevTap = pointerEvent;\n            }\n        },\n\n        validateSelector: function (pointer, event, matches, matchElements) {\n            for (var i = 0, len = matches.length; i < len; i++) {\n                var match = matches[i],\n                    matchElement = matchElements[i],\n                    action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\n                if (action && withinInteractionLimit(match, matchElement, action)) {\n                    this.target = match;\n                    this.element = matchElement;\n\n                    return action;\n                }\n            }\n        },\n\n        setSnapping: function (pageCoords, status) {\n            var snap = this.target.options[this.prepared.name].snap,\n                targets = [],\n                target,\n                page,\n                i;\n\n            status = status || this.snapStatus;\n\n            if (status.useStatusXY) {\n                page = { x: status.x, y: status.y };\n            }\n            else {\n                var origin = getOriginXY(this.target, this.element);\n\n                page = extend({}, pageCoords);\n\n                page.x -= origin.x;\n                page.y -= origin.y;\n            }\n\n            status.realX = page.x;\n            status.realY = page.y;\n\n            page.x = page.x - this.inertiaStatus.resumeDx;\n            page.y = page.y - this.inertiaStatus.resumeDy;\n\n            var len = snap.targets? snap.targets.length : 0;\n\n            for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n                var relative = {\n                    x: page.x - this.snapOffsets[relIndex].x,\n                    y: page.y - this.snapOffsets[relIndex].y\n                };\n\n                for (i = 0; i < len; i++) {\n                    if (isFunction(snap.targets[i])) {\n                        target = snap.targets[i](relative.x, relative.y, this);\n                    }\n                    else {\n                        target = snap.targets[i];\n                    }\n\n                    if (!target) { continue; }\n\n                    targets.push({\n                        x: isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,\n                        y: isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,\n\n                        range: isNumber(target.range)? target.range: snap.range\n                    });\n                }\n            }\n\n            var closest = {\n                    target: null,\n                    inRange: false,\n                    distance: 0,\n                    range: 0,\n                    dx: 0,\n                    dy: 0\n                };\n\n            for (i = 0, len = targets.length; i < len; i++) {\n                target = targets[i];\n\n                var range = target.range,\n                    dx = target.x - page.x,\n                    dy = target.y - page.y,\n                    distance = hypot(dx, dy),\n                    inRange = distance <= range;\n\n                // Infinite targets count as being out of range\n                // compared to non infinite ones that are in range\n                if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n                    inRange = false;\n                }\n\n                if (!closest.target || (inRange\n                    // is the closest target in range?\n                    ? (closest.inRange && range !== Infinity\n                        // the pointer is relatively deeper in this target\n                        ? distance / range < closest.distance / closest.range\n                        // this target has Infinite range and the closest doesn't\n                        : (range === Infinity && closest.range !== Infinity)\n                            // OR this target is closer that the previous closest\n                            || distance < closest.distance)\n                    // The other is not in range and the pointer is closer to this target\n                    : (!closest.inRange && distance < closest.distance))) {\n\n                    if (range === Infinity) {\n                        inRange = true;\n                    }\n\n                    closest.target = target;\n                    closest.distance = distance;\n                    closest.range = range;\n                    closest.inRange = inRange;\n                    closest.dx = dx;\n                    closest.dy = dy;\n\n                    status.range = range;\n                }\n            }\n\n            var snapChanged;\n\n            if (closest.target) {\n                snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\n                status.snappedX = closest.target.x;\n                status.snappedY = closest.target.y;\n            }\n            else {\n                snapChanged = true;\n\n                status.snappedX = NaN;\n                status.snappedY = NaN;\n            }\n\n            status.dx = closest.dx;\n            status.dy = closest.dy;\n\n            status.changed = (snapChanged || (closest.inRange && !status.locked));\n            status.locked = closest.inRange;\n\n            return status;\n        },\n\n        setRestriction: function (pageCoords, status) {\n            var target = this.target,\n                restrict = target && target.options[this.prepared.name].restrict,\n                restriction = restrict && restrict.restriction,\n                page;\n\n            if (!restriction) {\n                return status;\n            }\n\n            status = status || this.restrictStatus;\n\n            page = status.useStatusXY\n                    ? page = { x: status.x, y: status.y }\n                    : page = extend({}, pageCoords);\n\n            if (status.snap && status.snap.locked) {\n                page.x += status.snap.dx || 0;\n                page.y += status.snap.dy || 0;\n            }\n\n            page.x -= this.inertiaStatus.resumeDx;\n            page.y -= this.inertiaStatus.resumeDy;\n\n            status.dx = 0;\n            status.dy = 0;\n            status.restricted = false;\n\n            var rect, restrictedX, restrictedY;\n\n            if (isString(restriction)) {\n                if (restriction === 'parent') {\n                    restriction = parentElement(this.element);\n                }\n                else if (restriction === 'self') {\n                    restriction = target.getRect(this.element);\n                }\n                else {\n                    restriction = closest(this.element, restriction);\n                }\n\n                if (!restriction) { return status; }\n            }\n\n            if (isFunction(restriction)) {\n                restriction = restriction(page.x, page.y, this.element);\n            }\n\n            if (isElement(restriction)) {\n                restriction = getElementRect(restriction);\n            }\n\n            rect = restriction;\n\n            if (!restriction) {\n                restrictedX = page.x;\n                restrictedY = page.y;\n            }\n            // object is assumed to have\n            // x, y, width, height or\n            // left, top, right, bottom\n            else if ('x' in restriction && 'y' in restriction) {\n                restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);\n                restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );\n            }\n            else {\n                restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);\n                restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );\n            }\n\n            status.dx = restrictedX - page.x;\n            status.dy = restrictedY - page.y;\n\n            status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n            status.restricted = !!(status.dx || status.dy);\n\n            status.restrictedX = restrictedX;\n            status.restrictedY = restrictedY;\n\n            return status;\n        },\n\n        checkAndPreventDefault: function (event, interactable, element) {\n            if (!(interactable = interactable || this.target)) { return; }\n\n            var options = interactable.options,\n                prevent = options.preventDefault;\n\n            if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n                // do not preventDefault on pointerdown if the prepared action is a drag\n                // and dragging can only start from a certain direction - this allows\n                // a touch to pan the viewport if a drag isn't in the right direction\n                if (/down|start/i.test(event.type)\n                    && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\n                    return;\n                }\n\n                // with manualStart, only preventDefault while interacting\n                if (options[this.prepared.name] && options[this.prepared.name].manualStart\n                    && !this.interacting()) {\n                    return;\n                }\n\n                event.preventDefault();\n                return;\n            }\n\n            if (prevent === 'always') {\n                event.preventDefault();\n                return;\n            }\n        },\n\n        calcInertia: function (status) {\n            var inertiaOptions = this.target.options[this.prepared.name].inertia,\n                lambda = inertiaOptions.resistance,\n                inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n            status.x0 = this.prevEvent.pageX;\n            status.y0 = this.prevEvent.pageY;\n            status.t0 = status.startEvent.timeStamp / 1000;\n            status.sx = status.sy = 0;\n\n            status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n            status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n            status.te = inertiaDur;\n\n            status.lambda_v0 = lambda / status.v0;\n            status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n        },\n\n        autoScrollMove: function (pointer) {\n            if (!(this.interacting()\n                && checkAutoScroll(this.target, this.prepared.name))) {\n                return;\n            }\n\n            if (this.inertiaStatus.active) {\n                autoScroll.x = autoScroll.y = 0;\n                return;\n            }\n\n            var top,\n                right,\n                bottom,\n                left,\n                options = this.target.options[this.prepared.name].autoScroll,\n                container = options.container || getWindow(this.element);\n\n            if (isWindow(container)) {\n                left   = pointer.clientX < autoScroll.margin;\n                top    = pointer.clientY < autoScroll.margin;\n                right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n                bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n            }\n            else {\n                var rect = getElementClientRect(container);\n\n                left   = pointer.clientX < rect.left   + autoScroll.margin;\n                top    = pointer.clientY < rect.top    + autoScroll.margin;\n                right  = pointer.clientX > rect.right  - autoScroll.margin;\n                bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n            }\n\n            autoScroll.x = (right ? 1: left? -1: 0);\n            autoScroll.y = (bottom? 1:  top? -1: 0);\n\n            if (!autoScroll.isScrolling) {\n                // set the autoScroll properties to those of the target\n                autoScroll.margin = options.margin;\n                autoScroll.speed  = options.speed;\n\n                autoScroll.start(this);\n            }\n        },\n\n        _updateEventTargets: function (target, currentTarget) {\n            this._eventTarget    = target;\n            this._curEventTarget = currentTarget;\n        }\n\n    };\n\n    function getInteractionFromPointer (pointer, eventType, eventTarget) {\n        var i = 0, len = interactions.length,\n            mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n                          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                          || pointer.pointerType === 4),\n            interaction;\n\n        var id = getPointerId(pointer);\n\n        // try to resume inertia with a new pointer\n        if (/down|start/i.test(eventType)) {\n            for (i = 0; i < len; i++) {\n                interaction = interactions[i];\n\n                var element = eventTarget;\n\n                if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n                    && (interaction.mouse === mouseEvent)) {\n                    while (element) {\n                        // if the element is the interaction element\n                        if (element === interaction.element) {\n                            return interaction;\n                        }\n                        element = parentElement(element);\n                    }\n                }\n            }\n        }\n\n        // if it's a mouse interaction\n        if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\n            // find a mouse interaction that's not in inertia phase\n            for (i = 0; i < len; i++) {\n                if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n                    return interactions[i];\n                }\n            }\n\n            // find any interaction specifically for mouse.\n            // if the eventType is a mousedown, and inertia is active\n            // ignore the interaction\n            for (i = 0; i < len; i++) {\n                if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n                    return interaction;\n                }\n            }\n\n            // create a new interaction for mouse\n            interaction = new Interaction();\n            interaction.mouse = true;\n\n            return interaction;\n        }\n\n        // get interaction that has this pointer\n        for (i = 0; i < len; i++) {\n            if (contains(interactions[i].pointerIds, id)) {\n                return interactions[i];\n            }\n        }\n\n        // at this stage, a pointerUp should not return an interaction\n        if (/up|end|out/i.test(eventType)) {\n            return null;\n        }\n\n        // get first idle interaction\n        for (i = 0; i < len; i++) {\n            interaction = interactions[i];\n\n            if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n                && !interaction.interacting()\n                && !(!mouseEvent && interaction.mouse)) {\n\n                return interaction;\n            }\n        }\n\n        return new Interaction();\n    }\n\n    function doOnInteractions (method) {\n        return (function (event) {\n            var interaction,\n                eventTarget = getActualElement(event.path\n                                               ? event.path[0]\n                                               : event.target),\n                curEventTarget = getActualElement(event.currentTarget),\n                i;\n\n            if (supportsTouch && /touch/.test(event.type)) {\n                prevTouchTime = new Date().getTime();\n\n                for (i = 0; i < event.changedTouches.length; i++) {\n                    var pointer = event.changedTouches[i];\n\n                    interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\n                    if (!interaction) { continue; }\n\n                    interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                    interaction[method](pointer, event, eventTarget, curEventTarget);\n                }\n            }\n            else {\n                if (!supportsPointerEvent && /mouse/.test(event.type)) {\n                    // ignore mouse events while touch interactions are active\n                    for (i = 0; i < interactions.length; i++) {\n                        if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n                            return;\n                        }\n                    }\n\n                    // try to ignore mouse events that are simulated by the browser\n                    // after a touch event\n                    if (new Date().getTime() - prevTouchTime < 500) {\n                        return;\n                    }\n                }\n\n                interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\n                if (!interaction) { return; }\n\n                interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                interaction[method](event, event, eventTarget, curEventTarget);\n            }\n        });\n    }\n\n    function InteractEvent (interaction, event, action, phase, element, related) {\n        var client,\n            page,\n            target      = interaction.target,\n            snapStatus  = interaction.snapStatus,\n            restrictStatus  = interaction.restrictStatus,\n            pointers    = interaction.pointers,\n            deltaSource = (target && target.options || defaultOptions).deltaSource,\n            sourceX     = deltaSource + 'X',\n            sourceY     = deltaSource + 'Y',\n            options     = target? target.options: defaultOptions,\n            origin      = getOriginXY(target, element),\n            starting    = phase === 'start',\n            ending      = phase === 'end',\n            coords      = starting? interaction.startCoords : interaction.curCoords;\n\n        element = element || interaction.element;\n\n        page   = extend({}, coords.page);\n        client = extend({}, coords.client);\n\n        page.x -= origin.x;\n        page.y -= origin.y;\n\n        client.x -= origin.x;\n        client.y -= origin.y;\n\n        var relativePoints = options[action].snap && options[action].snap.relativePoints ;\n\n        if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n            this.snap = {\n                range  : snapStatus.range,\n                locked : snapStatus.locked,\n                x      : snapStatus.snappedX,\n                y      : snapStatus.snappedY,\n                realX  : snapStatus.realX,\n                realY  : snapStatus.realY,\n                dx     : snapStatus.dx,\n                dy     : snapStatus.dy\n            };\n\n            if (snapStatus.locked) {\n                page.x += snapStatus.dx;\n                page.y += snapStatus.dy;\n                client.x += snapStatus.dx;\n                client.y += snapStatus.dy;\n            }\n        }\n\n        if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n            page.x += restrictStatus.dx;\n            page.y += restrictStatus.dy;\n            client.x += restrictStatus.dx;\n            client.y += restrictStatus.dy;\n\n            this.restrict = {\n                dx: restrictStatus.dx,\n                dy: restrictStatus.dy\n            };\n        }\n\n        this.pageX     = page.x;\n        this.pageY     = page.y;\n        this.clientX   = client.x;\n        this.clientY   = client.y;\n\n        this.x0        = interaction.startCoords.page.x - origin.x;\n        this.y0        = interaction.startCoords.page.y - origin.y;\n        this.clientX0  = interaction.startCoords.client.x - origin.x;\n        this.clientY0  = interaction.startCoords.client.y - origin.y;\n        this.ctrlKey   = event.ctrlKey;\n        this.altKey    = event.altKey;\n        this.shiftKey  = event.shiftKey;\n        this.metaKey   = event.metaKey;\n        this.button    = event.button;\n        this.buttons   = event.buttons;\n        this.target    = element;\n        this.t0        = interaction.downTimes[0];\n        this.type      = action + (phase || '');\n\n        this.interaction = interaction;\n        this.interactable = target;\n\n        var inertiaStatus = interaction.inertiaStatus;\n\n        if (inertiaStatus.active) {\n            this.detail = 'inertia';\n        }\n\n        if (related) {\n            this.relatedTarget = related;\n        }\n\n        // end event dx, dy is difference between start and end points\n        if (ending) {\n            if (deltaSource === 'client') {\n                this.dx = client.x - interaction.startCoords.client.x;\n                this.dy = client.y - interaction.startCoords.client.y;\n            }\n            else {\n                this.dx = page.x - interaction.startCoords.page.x;\n                this.dy = page.y - interaction.startCoords.page.y;\n            }\n        }\n        else if (starting) {\n            this.dx = 0;\n            this.dy = 0;\n        }\n        // copy properties from previousmove if starting inertia\n        else if (phase === 'inertiastart') {\n            this.dx = interaction.prevEvent.dx;\n            this.dy = interaction.prevEvent.dy;\n        }\n        else {\n            if (deltaSource === 'client') {\n                this.dx = client.x - interaction.prevEvent.clientX;\n                this.dy = client.y - interaction.prevEvent.clientY;\n            }\n            else {\n                this.dx = page.x - interaction.prevEvent.pageX;\n                this.dy = page.y - interaction.prevEvent.pageY;\n            }\n        }\n        if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n            && !inertiaStatus.active\n            && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\n            inertiaStatus.resumeDx += this.dx;\n            inertiaStatus.resumeDy += this.dy;\n\n            this.dx = this.dy = 0;\n        }\n\n        if (action === 'resize' && interaction.resizeAxes) {\n            if (options.resize.square) {\n                if (interaction.resizeAxes === 'y') {\n                    this.dx = this.dy;\n                }\n                else {\n                    this.dy = this.dx;\n                }\n                this.axes = 'xy';\n            }\n            else {\n                this.axes = interaction.resizeAxes;\n\n                if (interaction.resizeAxes === 'x') {\n                    this.dy = 0;\n                }\n                else if (interaction.resizeAxes === 'y') {\n                    this.dx = 0;\n                }\n            }\n        }\n        else if (action === 'gesture') {\n            this.touches = [pointers[0], pointers[1]];\n\n            if (starting) {\n                this.distance = touchDistance(pointers, deltaSource);\n                this.box      = touchBBox(pointers);\n                this.scale    = 1;\n                this.ds       = 0;\n                this.angle    = touchAngle(pointers, undefined, deltaSource);\n                this.da       = 0;\n            }\n            else if (ending || event instanceof InteractEvent) {\n                this.distance = interaction.prevEvent.distance;\n                this.box      = interaction.prevEvent.box;\n                this.scale    = interaction.prevEvent.scale;\n                this.ds       = this.scale - 1;\n                this.angle    = interaction.prevEvent.angle;\n                this.da       = this.angle - interaction.gesture.startAngle;\n            }\n            else {\n                this.distance = touchDistance(pointers, deltaSource);\n                this.box      = touchBBox(pointers);\n                this.scale    = this.distance / interaction.gesture.startDistance;\n                this.angle    = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n                this.ds = this.scale - interaction.gesture.prevScale;\n                this.da = this.angle - interaction.gesture.prevAngle;\n            }\n        }\n\n        if (starting) {\n            this.timeStamp = interaction.downTimes[0];\n            this.dt        = 0;\n            this.duration  = 0;\n            this.speed     = 0;\n            this.velocityX = 0;\n            this.velocityY = 0;\n        }\n        else if (phase === 'inertiastart') {\n            this.timeStamp = interaction.prevEvent.timeStamp;\n            this.dt        = interaction.prevEvent.dt;\n            this.duration  = interaction.prevEvent.duration;\n            this.speed     = interaction.prevEvent.speed;\n            this.velocityX = interaction.prevEvent.velocityX;\n            this.velocityY = interaction.prevEvent.velocityY;\n        }\n        else {\n            this.timeStamp = new Date().getTime();\n            this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n            this.duration  = this.timeStamp - interaction.downTimes[0];\n\n            if (event instanceof InteractEvent) {\n                var dx = this[sourceX] - interaction.prevEvent[sourceX],\n                    dy = this[sourceY] - interaction.prevEvent[sourceY],\n                    dt = this.dt / 1000;\n\n                this.speed = hypot(dx, dy) / dt;\n                this.velocityX = dx / dt;\n                this.velocityY = dy / dt;\n            }\n            // if normal move or end event, use previous user event coords\n            else {\n                // speed and velocity in pixels per second\n                this.speed = interaction.pointerDelta[deltaSource].speed;\n                this.velocityX = interaction.pointerDelta[deltaSource].vx;\n                this.velocityY = interaction.pointerDelta[deltaSource].vy;\n            }\n        }\n\n        if ((ending || phase === 'inertiastart')\n            && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n            var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n                overlap = 22.5;\n\n            if (angle < 0) {\n                angle += 360;\n            }\n\n            var left = 135 - overlap <= angle && angle < 225 + overlap,\n                up   = 225 - overlap <= angle && angle < 315 + overlap,\n\n                right = !left && (315 - overlap <= angle || angle <  45 + overlap),\n                down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n            this.swipe = {\n                up   : up,\n                down : down,\n                left : left,\n                right: right,\n                angle: angle,\n                speed: interaction.prevEvent.speed,\n                velocity: {\n                    x: interaction.prevEvent.velocityX,\n                    y: interaction.prevEvent.velocityY\n                }\n            };\n        }\n    }\n\n    InteractEvent.prototype = {\n        preventDefault: blank,\n        stopImmediatePropagation: function () {\n            this.immediatePropagationStopped = this.propagationStopped = true;\n        },\n        stopPropagation: function () {\n            this.propagationStopped = true;\n        }\n    };\n\n    function preventOriginalDefault () {\n        this.originalEvent.preventDefault();\n    }\n\n    function getActionCursor (action) {\n        var cursor = '';\n\n        if (action.name === 'drag') {\n            cursor =  actionCursors.drag;\n        }\n        if (action.name === 'resize') {\n            if (action.axis) {\n                cursor =  actionCursors[action.name + action.axis];\n            }\n            else if (action.edges) {\n                var cursorKey = 'resize',\n                    edgeNames = ['top', 'bottom', 'left', 'right'];\n\n                for (var i = 0; i < 4; i++) {\n                    if (action.edges[edgeNames[i]]) {\n                        cursorKey += edgeNames[i];\n                    }\n                }\n\n                cursor = actionCursors[cursorKey];\n            }\n        }\n\n        return cursor;\n    }\n\n    function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n        // false, '', undefined, null\n        if (!value) { return false; }\n\n        // true value, use pointer coords and element rect\n        if (value === true) {\n            // if dimensions are negative, \"switch\" edges\n            var width = isNumber(rect.width)? rect.width : rect.right - rect.left,\n                height = isNumber(rect.height)? rect.height : rect.bottom - rect.top;\n\n            if (width < 0) {\n                if      (name === 'left' ) { name = 'right'; }\n                else if (name === 'right') { name = 'left' ; }\n            }\n            if (height < 0) {\n                if      (name === 'top'   ) { name = 'bottom'; }\n                else if (name === 'bottom') { name = 'top'   ; }\n            }\n\n            if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n            if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n            if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n            if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n        }\n\n        // the remaining checks require an element\n        if (!isElement(element)) { return false; }\n\n        return isElement(value)\n                    // the value is an element to use as a resize handle\n                    ? value === element\n                    // otherwise check if element matches value as selector\n                    : matchesUpTo(element, value, interactableElement);\n    }\n\n    function defaultActionChecker (pointer, interaction, element) {\n        var rect = this.getRect(element),\n            shouldResize = false,\n            action = null,\n            resizeAxes = null,\n            resizeEdges,\n            page = extend({}, interaction.curCoords.page),\n            options = this.options;\n\n        if (!rect) { return null; }\n\n        if (actionIsEnabled.resize && options.resize.enabled) {\n            var resizeOptions = options.resize;\n\n            resizeEdges = {\n                left: false, right: false, top: false, bottom: false\n            };\n\n            // if using resize.edges\n            if (isObject(resizeOptions.edges)) {\n                for (var edge in resizeEdges) {\n                    resizeEdges[edge] = checkResizeEdge(edge,\n                                                        resizeOptions.edges[edge],\n                                                        page,\n                                                        interaction._eventTarget,\n                                                        element,\n                                                        rect,\n                                                        resizeOptions.margin || margin);\n                }\n\n                resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n                resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n                shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n            }\n            else {\n                var right  = options.resize.axis !== 'y' && page.x > (rect.right  - margin),\n                    bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - margin);\n\n                shouldResize = right || bottom;\n                resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');\n            }\n        }\n\n        action = shouldResize\n            ? 'resize'\n            : actionIsEnabled.drag && options.drag.enabled\n                ? 'drag'\n                : null;\n\n        if (actionIsEnabled.gesture\n            && interaction.pointerIds.length >=2\n            && !(interaction.dragging || interaction.resizing)) {\n            action = 'gesture';\n        }\n\n        if (action) {\n            return {\n                name: action,\n                axis: resizeAxes,\n                edges: resizeEdges\n            };\n        }\n\n        return null;\n    }\n\n    // Check if action is enabled globally and the current target supports it\n    // If so, return the validated action. Otherwise, return null\n    function validateAction (action, interactable) {\n        if (!isObject(action)) { return null; }\n\n        var actionName = action.name,\n            options = interactable.options;\n\n        if ((  (actionName  === 'resize'   && options.resize.enabled )\n            || (actionName      === 'drag'     && options.drag.enabled  )\n            || (actionName      === 'gesture'  && options.gesture.enabled))\n            && actionIsEnabled[actionName]) {\n\n            if (actionName === 'resize' || actionName === 'resizeyx') {\n                actionName = 'resizexy';\n            }\n\n            return action;\n        }\n        return null;\n    }\n\n    var listeners = {},\n        interactionListeners = [\n            'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',\n            'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n            'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n            'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'\n        ];\n\n    for (var i = 0, len = interactionListeners.length; i < len; i++) {\n        var name = interactionListeners[i];\n\n        listeners[name] = doOnInteractions(name);\n    }\n\n    // bound to the interactable context when a DOM event\n    // listener is added to a selector interactable\n    function delegateListener (event, useCapture) {\n        var fakeEvent = {},\n            delegated = delegatedEvents[event.type],\n            eventTarget = getActualElement(event.path\n                                           ? event.path[0]\n                                           : event.target),\n            element = eventTarget;\n\n        useCapture = useCapture? true: false;\n\n        // duplicate the event so that currentTarget can be changed\n        for (var prop in event) {\n            fakeEvent[prop] = event[prop];\n        }\n\n        fakeEvent.originalEvent = event;\n        fakeEvent.preventDefault = preventOriginalDefault;\n\n        // climb up document tree looking for selector matches\n        while (isElement(element)) {\n            for (var i = 0; i < delegated.selectors.length; i++) {\n                var selector = delegated.selectors[i],\n                    context = delegated.contexts[i];\n\n                if (matchesSelector(element, selector)\n                    && nodeContains(context, eventTarget)\n                    && nodeContains(context, element)) {\n\n                    var listeners = delegated.listeners[i];\n\n                    fakeEvent.currentTarget = element;\n\n                    for (var j = 0; j < listeners.length; j++) {\n                        if (listeners[j][1] === useCapture) {\n                            listeners[j][0](fakeEvent);\n                        }\n                    }\n                }\n            }\n\n            element = parentElement(element);\n        }\n    }\n\n    function delegateUseCapture (event) {\n        return delegateListener.call(this, event, true);\n    }\n\n    interactables.indexOfElement = function indexOfElement (element, context) {\n        context = context || document;\n\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if ((interactable.selector === element\n                && (interactable._context === context))\n                || (!interactable.selector && interactable._element === element)) {\n\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    interactables.get = function interactableGet (element, options) {\n        return this[this.indexOfElement(element, options && options.context)];\n    };\n\n    interactables.forEachSelector = function (callback) {\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if (!interactable.selector) {\n                continue;\n            }\n\n            var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n    };\n\n    /*\\\n     * interact\n     [ method ]\n     *\n     * The methods of this variable can be used to set elements as\n     * interactables and also to change various default settings.\n     *\n     * Calling it as a function and passing an element or a valid CSS selector\n     * string returns an Interactable object which has various methods to\n     * configure it.\n     *\n     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n     = (object) An @Interactable\n     *\n     > Usage\n     | interact(document.getElementById('draggable')).draggable(true);\n     |\n     | var rectables = interact('rect');\n     | rectables\n     |     .gesturable(true)\n     |     .on('gesturemove', function (event) {\n     |         // something cool...\n     |     })\n     |     .autoScroll(true);\n    \\*/\n    function interact (element, options) {\n        return interactables.get(element, options) || new Interactable(element, options);\n    }\n\n    /*\\\n     * Interactable\n     [ property ]\n     **\n     * Object type returned by @interact\n    \\*/\n    function Interactable (element, options) {\n        this._element = element;\n        this._iEvents = this._iEvents || {};\n\n        var _window;\n\n        if (trySelector(element)) {\n            this.selector = element;\n\n            var context = options && options.context;\n\n            _window = context? getWindow(context) : window;\n\n            if (context && (_window.Node\n                    ? context instanceof _window.Node\n                    : (isElement(context) || context === _window.document))) {\n\n                this._context = context;\n            }\n        }\n        else {\n            _window = getWindow(element);\n\n            if (isElement(element, _window)) {\n\n                if (supportsPointerEvent) {\n                    events.add(this._element, pEventTypes.down, listeners.pointerDown );\n                    events.add(this._element, pEventTypes.move, listeners.pointerHover);\n                }\n                else {\n                    events.add(this._element, 'mousedown' , listeners.pointerDown );\n                    events.add(this._element, 'mousemove' , listeners.pointerHover);\n                    events.add(this._element, 'touchstart', listeners.pointerDown );\n                    events.add(this._element, 'touchmove' , listeners.pointerHover);\n                }\n            }\n        }\n\n        this._doc = _window.document;\n\n        if (!contains(documents, this._doc)) {\n            listenToDocument(this._doc);\n        }\n\n        interactables.push(this);\n\n        this.set(options);\n    }\n\n    Interactable.prototype = {\n        setOnEvents: function (action, phases) {\n            if (action === 'drop') {\n                if (isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }\n                if (isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }\n                if (isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }\n                if (isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }\n                if (isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }\n                if (isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }\n            }\n            else {\n                action = 'on' + action;\n\n                if (isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }\n                if (isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }\n                if (isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }\n                if (isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.draggable\n         [ method ]\n         *\n         * Gets or sets whether drag actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of drag events\n         | var isDraggable = interact('ul li').draggable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n         = (object) This Interactable\n         | interact(element).draggable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // the axis in which the first movement must be\n         |     // for the drag sequence to start\n         |     // 'xy' by default - any direction\n         |     axis: 'x' || 'y' || 'xy',\n         |\n         |     // max number of drags that can happen concurrently\n         |     // with elements of this Interactable. Infinity by default\n         |     max: Infinity,\n         |\n         |     // max number of drags that can target the same element+Interactable\n         |     // 1 by default\n         |     maxPerElement: 2\n         | });\n        \\*/\n        draggable: function (options) {\n            if (isObject(options)) {\n                this.options.drag.enabled = options.enabled === false? false: true;\n                this.setPerAction('drag', options);\n                this.setOnEvents('drag', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.drag.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    delete this.options.drag.axis;\n                }\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.drag.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drag;\n        },\n\n        setPerAction: function (action, options) {\n            // for all the default per-action options\n            for (var option in options) {\n                // if this option exists for this action\n                if (option in defaultOptions[action]) {\n                    // if the option in the options arg is an object value\n                    if (isObject(options[option])) {\n                        // duplicate the object\n                        this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n                        if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n                            this.options[action][option].enabled = options[option].enabled === false? false : true;\n                        }\n                    }\n                    else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n                        this.options[action][option].enabled = options[option];\n                    }\n                    else if (options[option] !== undefined) {\n                        // or if it's not undefined, do a plain assignment\n                        this.options[action][option] = options[option];\n                    }\n                }\n            }\n        },\n\n        /*\\\n         * Interactable.dropzone\n         [ method ]\n         *\n         * Returns or sets whether elements can be dropped onto this\n         * Interactable to trigger drop events\n         *\n         * Dropzones can receive the following events:\n         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n         *  - `dragmove` when a draggable that has entered the dropzone is moved\n         *  - `drop` when a draggable is dropped into this dropzone\n         *\n         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n         *\n         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n         *   - `'pointer'`, the pointer must be over the dropzone (default)\n         *   - `'center'`, the draggable element's center must be over the dropzone\n         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n         *       e.g. `0.5` for drop to happen when half of the area of the\n         *       draggable is over the dropzone\n         *\n         - options (boolean | object | null) #optional The new value to be set.\n         | interact('.drop').dropzone({\n         |   accept: '.can-drop' || document.getElementById('single-drop'),\n         |   overlap: 'pointer' || 'center' || zeroToOne\n         | }\n         = (boolean | object) The current setting or this Interactable\n        \\*/\n        dropzone: function (options) {\n            if (isObject(options)) {\n                this.options.drop.enabled = options.enabled === false? false: true;\n                this.setOnEvents('drop', options);\n\n                if (/^(pointer|center)$/.test(options.overlap)) {\n                    this.options.drop.overlap = options.overlap;\n                }\n                else if (isNumber(options.overlap)) {\n                    this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n                }\n                if ('accept' in options) {\n                  this.options.drop.accept = options.accept;\n                }\n                if ('checker' in options) {\n                  this.options.drop.checker = options.checker;\n                }\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.drop.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drop;\n        },\n\n        dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n            var dropped = false;\n\n            // if the dropzone has no rect (eg. display: none)\n            // call the custom dropChecker or just return false\n            if (!(rect = rect || this.getRect(dropElement))) {\n                return (this.options.drop.checker\n                    ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n                    : false);\n            }\n\n            var dropOverlap = this.options.drop.overlap;\n\n            if (dropOverlap === 'pointer') {\n                var page = getPageXY(dragEvent),\n                    origin = getOriginXY(draggable, draggableElement),\n                    horizontal,\n                    vertical;\n\n                page.x += origin.x;\n                page.y += origin.y;\n\n                horizontal = (page.x > rect.left) && (page.x < rect.right);\n                vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n                dropped = horizontal && vertical;\n            }\n\n            var dragRect = draggable.getRect(draggableElement);\n\n            if (dropOverlap === 'center') {\n                var cx = dragRect.left + dragRect.width  / 2,\n                    cy = dragRect.top  + dragRect.height / 2;\n\n                dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n            }\n\n            if (isNumber(dropOverlap)) {\n                var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                                  * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),\n                    overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n                dropped = overlapRatio >= dropOverlap;\n            }\n\n            if (this.options.drop.checker) {\n                dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n            }\n\n            return dropped;\n        },\n\n        /*\\\n         * Interactable.dropChecker\n         [ method ]\n         *\n         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n         *\n         * Gets or sets the function used to check if a dragged element is\n         * over this Interactable.\n         *\n         - checker (function) #optional The function that will be called when checking for a drop\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         * The checker function takes the following arguments:\n         *\n         - dragEvent (InteractEvent) The related dragmove or dragend event\n         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n         - dropped (boolean) The value from the default drop checker\n         - dropzone (Interactable) The dropzone interactable\n         - dropElement (Element) The dropzone element\n         - draggable (Interactable) The Interactable being dragged\n         - draggableElement (Element) The actual element that's being dragged\n         *\n         > Usage:\n         | interact(target)\n         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n         |                       dropped,           // bool result of the default checker\n         |                       dropzone,          // dropzone Interactable\n         |                       dropElement,       // dropzone elemnt\n         |                       draggable,         // draggable Interactable\n         |                       draggableElement) {// draggable element\n         |\n         |   return dropped && event.target.hasAttribute('allow-drop');\n         | }\n        \\*/\n        dropChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.options.drop.checker = checker;\n\n                return this;\n            }\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.options.drop.checker;\n        },\n\n        /*\\\n         * Interactable.accept\n         [ method ]\n         *\n         * Deprecated. add an `accept` property to the options object passed to\n         * @Interactable.dropzone instead.\n         *\n         * Gets or sets the Element or CSS selector match that this\n         * Interactable accepts if it is a dropzone.\n         *\n         - newValue (Element | string | null) #optional\n         * If it is an Element, then only that element can be dropped into this dropzone.\n         * If it is a string, the element being dragged must match it as a selector.\n         * If it is null, the accept options is cleared - it accepts any element.\n         *\n         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n        \\*/\n        accept: function (newValue) {\n            if (isElement(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            // test if it is a valid CSS selector\n            if (trySelector(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.drop.accept;\n\n                return this;\n            }\n\n            return this.options.drop.accept;\n        },\n\n        /*\\\n         * Interactable.resizable\n         [ method ]\n         *\n         * Gets or sets whether resize actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of resize elements\n         | var isResizeable = interact('input[type=text]').resizable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n         = (object) This Interactable\n         | interact(element).resizable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     edges: {\n         |       top   : true,       // Use pointer coords to check for resize.\n         |       left  : false,      // Disable resizing from left edge.\n         |       bottom: '.resize-s',// Resize if pointer target matches selector\n         |       right : handleEl    // Resize if pointer target is the given Element\n         |     },\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height are adjusted at a 1:1 ratio.\n         |     square: false,\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height maintain the aspect ratio they had when resizing started.\n         |     preserveAspectRatio: false,\n         |\n         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n         |     // 'negate' will allow the rect to have negative width/height\n         |     // 'reposition' will keep the width/height positive by swapping\n         |     // the top and bottom edges and/or swapping the left and right edges\n         |     invert: 'none' || 'negate' || 'reposition'\n         |\n         |     // limit multiple resizes.\n         |     // See the explanation in the @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        resizable: function (options) {\n            if (isObject(options)) {\n                this.options.resize.enabled = options.enabled === false? false: true;\n                this.setPerAction('resize', options);\n                this.setOnEvents('resize', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.resize.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    this.options.resize.axis = defaultOptions.resize.axis;\n                }\n\n                if (isBool(options.preserveAspectRatio)) {\n                    this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n                }\n                else if (isBool(options.square)) {\n                    this.options.resize.square = options.square;\n                }\n\n                return this;\n            }\n            if (isBool(options)) {\n                this.options.resize.enabled = options;\n\n                return this;\n            }\n            return this.options.resize;\n        },\n\n        /*\\\n         * Interactable.squareResize\n         [ method ]\n         *\n         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n         *\n         * Gets or sets whether resizing is forced 1:1 aspect\n         *\n         = (boolean) Current setting\n         *\n         * or\n         *\n         - newValue (boolean) #optional\n         = (object) this Interactable\n        \\*/\n        squareResize: function (newValue) {\n            if (isBool(newValue)) {\n                this.options.resize.square = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.resize.square;\n\n                return this;\n            }\n\n            return this.options.resize.square;\n        },\n\n        /*\\\n         * Interactable.gesturable\n         [ method ]\n         *\n         * Gets or sets whether multitouch gestures can be performed on the\n         * Interactable's element\n         *\n         = (boolean) Indicates if this can be the target of gesture events\n         | var isGestureable = interact(element).gesturable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n         = (object) this Interactable\n         | interact(element).gesturable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // limit multiple gestures.\n         |     // See the explanation in @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        gesturable: function (options) {\n            if (isObject(options)) {\n                this.options.gesture.enabled = options.enabled === false? false: true;\n                this.setPerAction('gesture', options);\n                this.setOnEvents('gesture', options);\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.gesture.enabled = options;\n\n                return this;\n            }\n\n            return this.options.gesture;\n        },\n\n        /*\\\n         * Interactable.autoScroll\n         [ method ]\n         **\n         * Deprecated. Add an `autoscroll` property to the options object\n         * passed to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets whether dragging and resizing near the edges of the\n         * window/container trigger autoScroll for this Interactable\n         *\n         = (object) Object with autoScroll properties\n         *\n         * or\n         *\n         - options (object | boolean) #optional\n         * options can be:\n         * - an object with margin, distance and interval properties,\n         * - true or false to enable or disable autoScroll or\n         = (Interactable) this Interactable\n        \\*/\n        autoScroll: function (options) {\n            if (isObject(options)) {\n                options = extend({ actions: ['drag', 'resize']}, options);\n            }\n            else if (isBool(options)) {\n                options = { actions: ['drag', 'resize'], enabled: options };\n            }\n\n            return this.setOptions('autoScroll', options);\n        },\n\n        /*\\\n         * Interactable.snap\n         [ method ]\n         **\n         * Deprecated. Add a `snap` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how action coordinates are snapped. By\n         * default, snapping is relative to the pointer coordinates. You can\n         * change this by setting the\n         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n         **\n         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | interact(document.querySelector('#thing')).snap({\n         |     targets: [\n         |         // snap to this specific point\n         |         {\n         |             x: 100,\n         |             y: 100,\n         |             range: 25\n         |         },\n         |         // give this function the x and y page coords and snap to the object returned\n         |         function (x, y) {\n         |             return {\n         |                 x: x,\n         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n         |                 range: 40\n         |             };\n         |         },\n         |         // create a function that snaps to a grid\n         |         interact.createSnapGrid({\n         |             x: 50,\n         |             y: 50,\n         |             range: 10,              // optional\n         |             offset: { x: 5, y: 10 } // optional\n         |         })\n         |     ],\n         |     // do not snap during normal movement.\n         |     // Instead, trigger only one snapped move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     relativePoints: [\n         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n         |         { x: 1, y: 1 },  // and also to the bottom right\n         |     ],  \n         |\n         |     // offset the snap target coordinates\n         |     // can be an object with x/y or 'startCoords'\n         |     offset: { x: 50, y: 50 }\n         |   }\n         | });\n        \\*/\n        snap: function (options) {\n            var ret = this.setOptions('snap', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        setOptions: function (option, options) {\n            var actions = options && isArray(options.actions)\n                    ? options.actions\n                    : ['drag'];\n\n            var i;\n\n            if (isObject(options) || isBool(options)) {\n                for (i = 0; i < actions.length; i++) {\n                    var action = /resize/.test(actions[i])? 'resize' : actions[i];\n\n                    if (!isObject(this.options[action])) { continue; }\n\n                    var thisOption = this.options[action][option];\n\n                    if (isObject(options)) {\n                        extend(thisOption, options);\n                        thisOption.enabled = options.enabled === false? false: true;\n\n                        if (option === 'snap') {\n                            if (thisOption.mode === 'grid') {\n                                thisOption.targets = [\n                                    interact.createSnapGrid(extend({\n                                        offset: thisOption.gridOffset || { x: 0, y: 0 }\n                                    }, thisOption.grid || {}))\n                                ];\n                            }\n                            else if (thisOption.mode === 'anchor') {\n                                thisOption.targets = thisOption.anchors;\n                            }\n                            else if (thisOption.mode === 'path') {\n                                thisOption.targets = thisOption.paths;\n                            }\n\n                            if ('elementOrigin' in options) {\n                                thisOption.relativePoints = [options.elementOrigin];\n                            }\n                        }\n                    }\n                    else if (isBool(options)) {\n                        thisOption.enabled = options;\n                    }\n                }\n\n                return this;\n            }\n\n            var ret = {},\n                allActions = ['drag', 'resize', 'gesture'];\n\n            for (i = 0; i < allActions.length; i++) {\n                if (option in defaultOptions[allActions[i]]) {\n                    ret[allActions[i]] = this.options[allActions[i]][option];\n                }\n            }\n\n            return ret;\n        },\n\n\n        /*\\\n         * Interactable.inertia\n         [ method ]\n         **\n         * Deprecated. Add an `inertia` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how events continue to run after the pointer is released\n         **\n         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | // enable and use default settings\n         | interact(element).inertia(true);\n         |\n         | // enable and use custom settings\n         | interact(element).inertia({\n         |     // value greater than 0\n         |     // high values slow the object down more quickly\n         |     resistance     : 16,\n         |\n         |     // the minimum launch speed (pixels per second) that results in inertia start\n         |     minSpeed       : 200,\n         |\n         |     // inertia will stop when the object slows down to this speed\n         |     endSpeed       : 20,\n         |\n         |     // boolean; should actions be resumed when the pointer goes down during inertia\n         |     allowResume    : true,\n         |\n         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n         |     zeroResumeDelta: false,\n         |\n         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n         |     // the pointer without triggering inertia will animate from the release\n         |     // point to the snaped/restricted point in the given amount of time (ms)\n         |     smoothEndDuration: 300,\n         |\n         |     // an array of action types that can have inertia (no gesture)\n         |     actions        : ['drag', 'resize']\n         | });\n         |\n         | // reset custom settings and use all defaults\n         | interact(element).inertia(null);\n        \\*/\n        inertia: function (options) {\n            var ret = this.setOptions('inertia', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        getAction: function (pointer, event, interaction, element) {\n            var action = this.defaultActionChecker(pointer, interaction, element);\n\n            if (this.options.actionChecker) {\n                return this.options.actionChecker(pointer, event, action, this, element, interaction);\n            }\n\n            return action;\n        },\n\n        defaultActionChecker: defaultActionChecker,\n\n        /*\\\n         * Interactable.actionChecker\n         [ method ]\n         *\n         * Gets or sets the function used to check action to be performed on\n         * pointerDown\n         *\n         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         | interact('.resize-drag')\n         |   .resizable(true)\n         |   .draggable(true)\n         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n         |\n         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n         |     // force drag with handle target\n         |     action.name = drag;\n         |   }\n         |   else {\n         |     // resize from the top and right edges\n         |     action.name  = 'resize';\n         |     action.edges = { top: true, right: true };\n         |   }\n         |\n         |   return action;\n         | });\n        \\*/\n        actionChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.options.actionChecker = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.actionChecker;\n\n                return this;\n            }\n\n            return this.options.actionChecker;\n        },\n\n        /*\\\n         * Interactable.getRect\n         [ method ]\n         *\n         * The default function to get an Interactables bounding rect. Can be\n         * overridden using @Interactable.rectChecker.\n         *\n         - element (Element) #optional The element to measure.\n         = (object) The object's bounding rectangle.\n         o {\n         o     top   : 0,\n         o     left  : 0,\n         o     bottom: 0,\n         o     right : 0,\n         o     width : 0,\n         o     height: 0\n         o }\n        \\*/\n        getRect: function rectCheck (element) {\n            element = element || this._element;\n\n            if (this.selector && !(isElement(element))) {\n                element = this._context.querySelector(this.selector);\n            }\n\n            return getElementRect(element);\n        },\n\n        /*\\\n         * Interactable.rectChecker\n         [ method ]\n         *\n         * Returns or sets the function used to calculate the interactable's\n         * element's rectangle\n         *\n         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n         = (function | object) The checker function or this Interactable\n        \\*/\n        rectChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.getRect = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.getRect;\n        },\n\n        /*\\\n         * Interactable.styleCursor\n         [ method ]\n         *\n         * Returns or sets whether the action that would be performed when the\n         * mouse on the element are checked on `mousemove` so that the cursor\n         * may be styled appropriately\n         *\n         - newValue (boolean) #optional\n         = (boolean | Interactable) The current setting or this Interactable\n        \\*/\n        styleCursor: function (newValue) {\n            if (isBool(newValue)) {\n                this.options.styleCursor = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.styleCursor;\n\n                return this;\n            }\n\n            return this.options.styleCursor;\n        },\n\n        /*\\\n         * Interactable.preventDefault\n         [ method ]\n         *\n         * Returns or sets whether to prevent the browser's default behaviour\n         * in response to pointer events. Can be set to:\n         *  - `'always'` to always prevent\n         *  - `'never'` to never prevent\n         *  - `'auto'` to let interact.js try to determine what would be best\n         *\n         - newValue (string) #optional `true`, `false` or `'auto'`\n         = (string | Interactable) The current setting or this Interactable\n        \\*/\n        preventDefault: function (newValue) {\n            if (/^(always|never|auto)$/.test(newValue)) {\n                this.options.preventDefault = newValue;\n                return this;\n            }\n\n            if (isBool(newValue)) {\n                this.options.preventDefault = newValue? 'always' : 'never';\n                return this;\n            }\n\n            return this.options.preventDefault;\n        },\n\n        /*\\\n         * Interactable.origin\n         [ method ]\n         *\n         * Gets or sets the origin of the Interactable's element.  The x and y\n         * of the origin will be subtracted from action event coordinates.\n         *\n         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n         * OR\n         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n         **\n         = (object) The current origin or this Interactable\n        \\*/\n        origin: function (newValue) {\n            if (trySelector(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n            else if (isObject(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n\n            return this.options.origin;\n        },\n\n        /*\\\n         * Interactable.deltaSource\n         [ method ]\n         *\n         * Returns or sets the mouse coordinate types used to calculate the\n         * movement of the pointer.\n         *\n         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n         = (string | object) The current deltaSource or this Interactable\n        \\*/\n        deltaSource: function (newValue) {\n            if (newValue === 'page' || newValue === 'client') {\n                this.options.deltaSource = newValue;\n\n                return this;\n            }\n\n            return this.options.deltaSource;\n        },\n\n        /*\\\n         * Interactable.restrict\n         [ method ]\n         **\n         * Deprecated. Add a `restrict` property to the options object passed to\n         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n         *\n         * Returns or sets the rectangles within which actions on this\n         * interactable (after snap calculations) are restricted. By default,\n         * restricting is relative to the pointer coordinates. You can change\n         * this by setting the\n         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n         **\n         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n         = (object) The current restrictions object or this Interactable\n         **\n         | interact(element).restrict({\n         |     // the rect will be `interact.getElementRect(element.parentNode)`\n         |     drag: element.parentNode,\n         |\n         |     // x and y are relative to the the interactable's origin\n         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n         | })\n         |\n         | interact('.draggable').restrict({\n         |     // the rect will be the selected element's parent\n         |     drag: 'parent',\n         |\n         |     // do not restrict during normal movement.\n         |     // Instead, trigger only one restricted move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n         | });\n        \\*/\n        restrict: function (options) {\n            if (!isObject(options)) {\n                return this.setOptions('restrict', options);\n            }\n\n            var actions = ['drag', 'resize', 'gesture'],\n                ret;\n\n            for (var i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                if (action in options) {\n                    var perAction = extend({\n                            actions: [action],\n                            restriction: options[action]\n                        }, options);\n\n                    ret = this.setOptions('restrict', perAction);\n                }\n            }\n\n            return ret;\n        },\n\n        /*\\\n         * Interactable.context\n         [ method ]\n         *\n         * Gets the selector context Node of the Interactable. The default is `window.document`.\n         *\n         = (Node) The context Node of this Interactable\n         **\n        \\*/\n        context: function () {\n            return this._context;\n        },\n\n        _context: document,\n\n        /*\\\n         * Interactable.ignoreFrom\n         [ method ]\n         *\n         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n         * event or any of it's parents match the given CSS selector or\n         * Element, no drag/resize/gesture is started.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n         = (string | Element | object) The current ignoreFrom value or this Interactable\n         **\n         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n         | // or\n         | interact(element).ignoreFrom('input, textarea, a');\n        \\*/\n        ignoreFrom: function (newValue) {\n            if (trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            if (isElement(newValue)) {              // specific element\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            return this.options.ignoreFrom;\n        },\n\n        /*\\\n         * Interactable.allowFrom\n         [ method ]\n         *\n         * A drag/resize/gesture is started only If the target of the\n         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n         * parents match the given CSS selector or Element.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n         = (string | Element | object) The current allowFrom value or this Interactable\n         **\n         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n         | // or\n         | interact(element).allowFrom('.handle');\n        \\*/\n        allowFrom: function (newValue) {\n            if (trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            if (isElement(newValue)) {              // specific element\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            return this.options.allowFrom;\n        },\n\n        /*\\\n         * Interactable.element\n         [ method ]\n         *\n         * If this is not a selector Interactable, it returns the element this\n         * interactable represents\n         *\n         = (Element) HTML / SVG Element\n        \\*/\n        element: function () {\n            return this._element;\n        },\n\n        /*\\\n         * Interactable.fire\n         [ method ]\n         *\n         * Calls listeners for the given InteractEvent type bound globally\n         * and directly to this Interactable\n         *\n         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n         = (Interactable) this Interactable\n        \\*/\n        fire: function (iEvent) {\n            if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n                return this;\n            }\n\n            var listeners,\n                i,\n                len,\n                onEvent = 'on' + iEvent.type,\n                funcName = '';\n\n            // Interactable#on() listeners\n            if (iEvent.type in this._iEvents) {\n                listeners = this._iEvents[iEvent.type];\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            // interactable.onevent listener\n            if (isFunction(this[onEvent])) {\n                funcName = this[onEvent].name;\n                this[onEvent](iEvent);\n            }\n\n            // interact.on() listeners\n            if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type]))  {\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.on\n         [ method ]\n         *\n         * Binds a listener for an InteractEvent or DOM event.\n         *\n         - eventType  (string | array | object) The types of events to listen for\n         - listener   (function) The function to be called on the given event(s)\n         - useCapture (boolean) #optional useCapture flag for addEventListener\n         = (object) This Interactable\n        \\*/\n        on: function (eventType, listener, useCapture) {\n            var i;\n\n            if (isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.on(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.on(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            if (eventType === 'wheel') {\n                eventType = wheelEvent;\n            }\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (contains(eventTypes, eventType)) {\n                // if this type of event was never bound to this Interactable\n                if (!(eventType in this._iEvents)) {\n                    this._iEvents[eventType] = [listener];\n                }\n                else {\n                    this._iEvents[eventType].push(listener);\n                }\n            }\n            // delegated event for selector\n            else if (this.selector) {\n                if (!delegatedEvents[eventType]) {\n                    delegatedEvents[eventType] = {\n                        selectors: [],\n                        contexts : [],\n                        listeners: []\n                    };\n\n                    // add delegate listener functions\n                    for (i = 0; i < documents.length; i++) {\n                        events.add(documents[i], eventType, delegateListener);\n                        events.add(documents[i], eventType, delegateUseCapture, true);\n                    }\n                }\n\n                var delegated = delegatedEvents[eventType],\n                    index;\n\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n                        break;\n                    }\n                }\n\n                if (index === -1) {\n                    index = delegated.selectors.length;\n\n                    delegated.selectors.push(this.selector);\n                    delegated.contexts .push(this._context);\n                    delegated.listeners.push([]);\n                }\n\n                // keep listener and useCapture flag\n                delegated.listeners[index].push([listener, useCapture]);\n            }\n            else {\n                events.add(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.off\n         [ method ]\n         *\n         * Removes an InteractEvent or DOM event listener\n         *\n         - eventType  (string | array | object) The types of events that were listened for\n         - listener   (function) The listener function to be removed\n         - useCapture (boolean) #optional useCapture flag for removeEventListener\n         = (object) This Interactable\n        \\*/\n        off: function (eventType, listener, useCapture) {\n            var i;\n\n            if (isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.off(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.off(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            var eventList,\n                index = -1;\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (eventType === 'wheel') {\n                eventType = wheelEvent;\n            }\n\n            // if it is an action event type\n            if (contains(eventTypes, eventType)) {\n                eventList = this._iEvents[eventType];\n\n                if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n                    this._iEvents[eventType].splice(index, 1);\n                }\n            }\n            // delegated event\n            else if (this.selector) {\n                var delegated = delegatedEvents[eventType],\n                    matchFound = false;\n\n                if (!delegated) { return this; }\n\n                // count from last index of delegated to 0\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    // look for matching selector and context Node\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n\n                        var listeners = delegated.listeners[index];\n\n                        // each item of the listeners array is an array: [function, useCaptureFlag]\n                        for (i = listeners.length - 1; i >= 0; i--) {\n                            var fn = listeners[i][0],\n                                useCap = listeners[i][1];\n\n                            // check if the listener functions and useCapture flags match\n                            if (fn === listener && useCap === useCapture) {\n                                // remove the listener from the array of listeners\n                                listeners.splice(i, 1);\n\n                                // if all listeners for this interactable have been removed\n                                // remove the interactable from the delegated arrays\n                                if (!listeners.length) {\n                                    delegated.selectors.splice(index, 1);\n                                    delegated.contexts .splice(index, 1);\n                                    delegated.listeners.splice(index, 1);\n\n                                    // remove delegate function from context\n                                    events.remove(this._context, eventType, delegateListener);\n                                    events.remove(this._context, eventType, delegateUseCapture, true);\n\n                                    // remove the arrays if they are empty\n                                    if (!delegated.selectors.length) {\n                                        delegatedEvents[eventType] = null;\n                                    }\n                                }\n\n                                // only remove one listener\n                                matchFound = true;\n                                break;\n                            }\n                        }\n\n                        if (matchFound) { break; }\n                    }\n                }\n            }\n            // remove listener from this Interatable's element\n            else {\n                events.remove(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.set\n         [ method ]\n         *\n         * Reset the options of this Interactable\n         - options (object) The new settings to apply\n         = (object) This Interactable\n        \\*/\n        set: function (options) {\n            if (!isObject(options)) {\n                options = {};\n            }\n\n            this.options = extend({}, defaultOptions.base);\n\n            var i,\n                actions = ['drag', 'drop', 'resize', 'gesture'],\n                methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n                perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\n            for (i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                this.options[action] = extend({}, defaultOptions[action]);\n\n                this.setPerAction(action, perActions);\n\n                this[methods[i]](options[action]);\n            }\n\n            var settings = [\n                    'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n                    'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n                    'rectChecker', 'styleCursor'\n                ];\n\n            for (i = 0, len = settings.length; i < len; i++) {\n                var setting = settings[i];\n\n                this.options[setting] = defaultOptions.base[setting];\n\n                if (setting in options) {\n                    this[setting](options[setting]);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.unset\n         [ method ]\n         *\n         * Remove this interactable from the list of interactables and remove\n         * it's drag, drop, resize and gesture capabilities\n         *\n         = (object) @interact\n        \\*/\n        unset: function () {\n            events.remove(this._element, 'all');\n\n            if (!isString(this.selector)) {\n                events.remove(this, 'all');\n                if (this.options.styleCursor) {\n                    this._element.style.cursor = '';\n                }\n            }\n            else {\n                // remove delegated events\n                for (var type in delegatedEvents) {\n                    var delegated = delegatedEvents[type];\n\n                    for (var i = 0; i < delegated.selectors.length; i++) {\n                        if (delegated.selectors[i] === this.selector\n                            && delegated.contexts[i] === this._context) {\n\n                            delegated.selectors.splice(i, 1);\n                            delegated.contexts .splice(i, 1);\n                            delegated.listeners.splice(i, 1);\n\n                            // remove the arrays if they are empty\n                            if (!delegated.selectors.length) {\n                                delegatedEvents[type] = null;\n                            }\n                        }\n\n                        events.remove(this._context, type, delegateListener);\n                        events.remove(this._context, type, delegateUseCapture, true);\n\n                        break;\n                    }\n                }\n            }\n\n            this.dropzone(false);\n\n            interactables.splice(indexOf(interactables, this), 1);\n\n            return interact;\n        }\n    };\n\n    function warnOnce (method, message) {\n        var warned = false;\n\n        return function () {\n            if (!warned) {\n                window.console.warn(message);\n                warned = true;\n            }\n\n            return method.apply(this, arguments);\n        };\n    }\n\n    Interactable.prototype.snap = warnOnce(Interactable.prototype.snap,\n         'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n    Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict,\n         'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n    Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia,\n         'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n    Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll,\n         'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n    Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize,\n         'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\n    Interactable.prototype.accept = warnOnce(Interactable.prototype.accept,\n         'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n    Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker,\n         'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n    Interactable.prototype.context = warnOnce(Interactable.prototype.context,\n         'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\n    /*\\\n     * interact.isSet\n     [ method ]\n     *\n     * Check if an element has been set\n     - element (Element) The Element being searched for\n     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n    \\*/\n    interact.isSet = function(element, options) {\n        return interactables.indexOfElement(element, options && options.context) !== -1;\n    };\n\n    /*\\\n     * interact.on\n     [ method ]\n     *\n     * Adds a global listener for an InteractEvent or adds a DOM event to\n     * `document`\n     *\n     - type       (string | array | object) The types of events to listen for\n     - listener   (function) The function to be called on the given event(s)\n     - useCapture (boolean) #optional useCapture flag for addEventListener\n     = (object) interact\n    \\*/\n    interact.on = function (type, listener, useCapture) {\n        if (isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.on(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (isObject(type)) {\n            for (var prop in type) {\n                interact.on(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        // if it is an InteractEvent type, add listener to globalEvents\n        if (contains(eventTypes, type)) {\n            // if this type of event was never bound\n            if (!globalEvents[type]) {\n                globalEvents[type] = [listener];\n            }\n            else {\n                globalEvents[type].push(listener);\n            }\n        }\n        // If non InteractEvent type, addEventListener to document\n        else {\n            events.add(document, type, listener, useCapture);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.off\n     [ method ]\n     *\n     * Removes a global InteractEvent listener or DOM event from `document`\n     *\n     - type       (string | array | object) The types of events that were listened for\n     - listener   (function) The listener function to be removed\n     - useCapture (boolean) #optional useCapture flag for removeEventListener\n     = (object) interact\n     \\*/\n    interact.off = function (type, listener, useCapture) {\n        if (isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.off(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (isObject(type)) {\n            for (var prop in type) {\n                interact.off(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        if (!contains(eventTypes, type)) {\n            events.remove(document, type, listener, useCapture);\n        }\n        else {\n            var index;\n\n            if (type in globalEvents\n                && (index = indexOf(globalEvents[type], listener)) !== -1) {\n                globalEvents[type].splice(index, 1);\n            }\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.enableDragging\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether dragging is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableDragging = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.drag = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.drag;\n    }, 'interact.enableDragging is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableResizing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether resizing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableResizing = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.resize = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.resize;\n    }, 'interact.enableResizing is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableGesturing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether gesturing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableGesturing = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.gesture = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.gesture;\n    }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\n    interact.eventTypes = eventTypes;\n\n    /*\\\n     * interact.debug\n     [ method ]\n     *\n     * Returns debugging data\n     = (object) An object with properties that outline the current state and expose internal functions and variables\n    \\*/\n    interact.debug = function () {\n        var interaction = interactions[0] || new Interaction();\n\n        return {\n            interactions          : interactions,\n            target                : interaction.target,\n            dragging              : interaction.dragging,\n            resizing              : interaction.resizing,\n            gesturing             : interaction.gesturing,\n            prepared              : interaction.prepared,\n            matches               : interaction.matches,\n            matchElements         : interaction.matchElements,\n\n            prevCoords            : interaction.prevCoords,\n            startCoords           : interaction.startCoords,\n\n            pointerIds            : interaction.pointerIds,\n            pointers              : interaction.pointers,\n            addPointer            : listeners.addPointer,\n            removePointer         : listeners.removePointer,\n            recordPointer        : listeners.recordPointer,\n\n            snap                  : interaction.snapStatus,\n            restrict              : interaction.restrictStatus,\n            inertia               : interaction.inertiaStatus,\n\n            downTime              : interaction.downTimes[0],\n            downEvent             : interaction.downEvent,\n            downPointer           : interaction.downPointer,\n            prevEvent             : interaction.prevEvent,\n\n            Interactable          : Interactable,\n            interactables         : interactables,\n            pointerIsDown         : interaction.pointerIsDown,\n            defaultOptions        : defaultOptions,\n            defaultActionChecker  : defaultActionChecker,\n\n            actionCursors         : actionCursors,\n            dragMove              : listeners.dragMove,\n            resizeMove            : listeners.resizeMove,\n            gestureMove           : listeners.gestureMove,\n            pointerUp             : listeners.pointerUp,\n            pointerDown           : listeners.pointerDown,\n            pointerMove           : listeners.pointerMove,\n            pointerHover          : listeners.pointerHover,\n\n            eventTypes            : eventTypes,\n\n            events                : events,\n            globalEvents          : globalEvents,\n            delegatedEvents       : delegatedEvents,\n\n            prefixedPropREs       : prefixedPropREs\n        };\n    };\n\n    // expose the functions used to calculate multi-touch properties\n    interact.getPointerAverage = pointerAverage;\n    interact.getTouchBBox     = touchBBox;\n    interact.getTouchDistance = touchDistance;\n    interact.getTouchAngle    = touchAngle;\n\n    interact.getElementRect         = getElementRect;\n    interact.getElementClientRect   = getElementClientRect;\n    interact.matchesSelector        = matchesSelector;\n    interact.closest                = closest;\n\n    /*\\\n     * interact.margin\n     [ method ]\n     *\n     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n     * Returns or sets the margin for autocheck resizing used in\n     * @Interactable.getAction. That is the distance from the bottom and right\n     * edges of an element clicking in which will start resizing\n     *\n     - newValue (number) #optional\n     = (number | interact) The current margin value or interact\n    \\*/\n    interact.margin = warnOnce(function (newvalue) {\n        if (isNumber(newvalue)) {\n            margin = newvalue;\n\n            return interact;\n        }\n        return margin;\n    },\n    'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.') ;\n\n    /*\\\n     * interact.supportsTouch\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports touch input\n    \\*/\n    interact.supportsTouch = function () {\n        return supportsTouch;\n    };\n\n    /*\\\n     * interact.supportsPointerEvent\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports PointerEvents\n    \\*/\n    interact.supportsPointerEvent = function () {\n        return supportsPointerEvent;\n    };\n\n    /*\\\n     * interact.stop\n     [ method ]\n     *\n     * Cancels all interactions (end events are not fired)\n     *\n     - event (Event) An event on which to call preventDefault()\n     = (object) interact\n    \\*/\n    interact.stop = function (event) {\n        for (var i = interactions.length - 1; i >= 0; i--) {\n            interactions[i].stop(event);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.dynamicDrop\n     [ method ]\n     *\n     * Returns or sets whether the dimensions of dropzone elements are\n     * calculated on every dragmove or only on dragstart for the default\n     * dropChecker\n     *\n     - newValue (boolean) #optional True to check on each move. False to check only before start\n     = (boolean | interact) The current setting or interact\n    \\*/\n    interact.dynamicDrop = function (newValue) {\n        if (isBool(newValue)) {\n            //if (dragging && dynamicDrop !== newValue && !newValue) {\n                //calcRects(dropzones);\n            //}\n\n            dynamicDrop = newValue;\n\n            return interact;\n        }\n        return dynamicDrop;\n    };\n\n    /*\\\n     * interact.pointerMoveTolerance\n     [ method ]\n     * Returns or sets the distance the pointer must be moved before an action\n     * sequence occurs. This also affects tolerance for tap events.\n     *\n     - newValue (number) #optional The movement from the start position must be greater than this value\n     = (number | Interactable) The current setting or interact\n    \\*/\n    interact.pointerMoveTolerance = function (newValue) {\n        if (isNumber(newValue)) {\n            pointerMoveTolerance = newValue;\n\n            return this;\n        }\n\n        return pointerMoveTolerance;\n    };\n\n    /*\\\n     * interact.maxInteractions\n     [ method ]\n     **\n     * Returns or sets the maximum number of concurrent interactions allowed.\n     * By default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables\n     * and elements, you need to enable it in the draggable, resizable and\n     * gesturable `'max'` and `'maxPerElement'` options.\n     **\n     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n    \\*/\n    interact.maxInteractions = function (newValue) {\n        if (isNumber(newValue)) {\n            maxInteractions = newValue;\n\n            return this;\n        }\n\n        return maxInteractions;\n    };\n\n    interact.createSnapGrid = function (grid) {\n        return function (x, y) {\n            var offsetX = 0,\n                offsetY = 0;\n\n            if (isObject(grid.offset)) {\n                offsetX = grid.offset.x;\n                offsetY = grid.offset.y;\n            }\n\n            var gridx = Math.round((x - offsetX) / grid.x),\n                gridy = Math.round((y - offsetY) / grid.y),\n\n                newX = gridx * grid.x + offsetX,\n                newY = gridy * grid.y + offsetY;\n\n            return {\n                x: newX,\n                y: newY,\n                range: grid.range\n            };\n        };\n    };\n\n    function endAllInteractions (event) {\n        for (var i = 0; i < interactions.length; i++) {\n            interactions[i].pointerEnd(event, event);\n        }\n    }\n\n    function listenToDocument (doc) {\n        if (contains(documents, doc)) { return; }\n\n        var win = doc.defaultView || doc.parentWindow;\n\n        // add delegate event listener\n        for (var eventType in delegatedEvents) {\n            events.add(doc, eventType, delegateListener);\n            events.add(doc, eventType, delegateUseCapture, true);\n        }\n\n        if (supportsPointerEvent) {\n            if (PointerEvent === win.MSPointerEvent) {\n                pEventTypes = {\n                    up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n                    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n            }\n            else {\n                pEventTypes = {\n                    up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n                    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n            }\n\n            events.add(doc, pEventTypes.down  , listeners.selectorDown );\n            events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n            events.add(doc, pEventTypes.over  , listeners.pointerOver  );\n            events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n            events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n            events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n        }\n        else {\n            events.add(doc, 'mousedown', listeners.selectorDown);\n            events.add(doc, 'mousemove', listeners.pointerMove );\n            events.add(doc, 'mouseup'  , listeners.pointerUp   );\n            events.add(doc, 'mouseover', listeners.pointerOver );\n            events.add(doc, 'mouseout' , listeners.pointerOut  );\n\n            events.add(doc, 'touchstart' , listeners.selectorDown );\n            events.add(doc, 'touchmove'  , listeners.pointerMove  );\n            events.add(doc, 'touchend'   , listeners.pointerUp    );\n            events.add(doc, 'touchcancel', listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, 'mousemove', listeners.autoScrollMove);\n            events.add(doc, 'touchmove', listeners.autoScrollMove);\n        }\n\n        events.add(win, 'blur', endAllInteractions);\n\n        try {\n            if (win.frameElement) {\n                var parentDoc = win.frameElement.ownerDocument,\n                    parentWindow = parentDoc.defaultView;\n\n                events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);\n                events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);\n                events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);\n                events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);\n                events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);\n                events.add(parentWindow, 'blur'         , endAllInteractions );\n            }\n        }\n        catch (error) {\n            interact.windowParentError = error;\n        }\n\n        // prevent native HTML5 drag on interact.js target elements\n        events.add(doc, 'dragstart', function (event) {\n            for (var i = 0; i < interactions.length; i++) {\n                var interaction = interactions[i];\n\n                if (interaction.element\n                    && (interaction.element === event.target\n                        || nodeContains(interaction.element, event.target))) {\n\n                    interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n                    return;\n                }\n            }\n        });\n\n        if (events.useAttachEvent) {\n            // For IE's lack of Event#preventDefault\n            events.add(doc, 'selectstart', function (event) {\n                var interaction = interactions[0];\n\n                if (interaction.currentAction()) {\n                    interaction.checkAndPreventDefault(event);\n                }\n            });\n\n            // For IE's bad dblclick event sequence\n            events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n        }\n\n        documents.push(doc);\n    }\n\n    listenToDocument(document);\n\n    function indexOf (array, target) {\n        for (var i = 0, len = array.length; i < len; i++) {\n            if (array[i] === target) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    function contains (array, target) {\n        return indexOf(array, target) !== -1;\n    }\n\n    function matchesSelector (element, selector, nodeList) {\n        if (ie8MatchesSelector) {\n            return ie8MatchesSelector(element, selector, nodeList);\n        }\n\n        // remove /deep/ from selectors if shadowDOM polyfill is used\n        if (window !== realWindow) {\n            selector = selector.replace(/\\/deep\\//g, ' ');\n        }\n\n        return element[prefixedMatchesSelector](selector);\n    }\n\n    function matchesUpTo (element, selector, limit) {\n        while (isElement(element)) {\n            if (matchesSelector(element, selector)) {\n                return true;\n            }\n\n            element = parentElement(element);\n\n            if (element === limit) {\n                return matchesSelector(element, selector);\n            }\n        }\n\n        return false;\n    }\n\n    // For IE8's lack of an Element#matchesSelector\n    // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n    if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n        ie8MatchesSelector = function (element, selector, elems) {\n            elems = elems || element.parentNode.querySelectorAll(selector);\n\n            for (var i = 0, len = elems.length; i < len; i++) {\n                if (elems[i] === element) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    // requestAnimationFrame polyfill\n    (function() {\n        var lastTime = 0,\n            vendors = ['ms', 'moz', 'webkit', 'o'];\n\n        for(var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n            reqFrame = realWindow[vendors[x]+'RequestAnimationFrame'];\n            cancelFrame = realWindow[vendors[x]+'CancelAnimationFrame'] || realWindow[vendors[x]+'CancelRequestAnimationFrame'];\n        }\n\n        if (!reqFrame) {\n            reqFrame = function(callback) {\n                var currTime = new Date().getTime(),\n                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n                    id = setTimeout(function() { callback(currTime + timeToCall); },\n                  timeToCall);\n                lastTime = currTime + timeToCall;\n                return id;\n            };\n        }\n\n        if (!cancelFrame) {\n            cancelFrame = function(id) {\n                clearTimeout(id);\n            };\n        }\n    }());\n\n    /* global exports: true, module, define */\n\n    // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = interact;\n        }\n        exports.interact = interact;\n    }\n    // AMD\n    else if (typeof define === 'function' && define.amd) {\n        define('interact', function() {\n            return interact;\n        });\n    }\n    else {\n        realWindow.interact = interact;\n    }\n\n} (typeof window === 'undefined'? undefined : window));\n"]}